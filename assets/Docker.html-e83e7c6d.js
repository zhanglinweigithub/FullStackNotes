import{_ as o,M as i,p as c,q as l,R as n,t as s,N as t,a1 as a}from"./framework-5866ffd3.js";const r="/FullStackNotes/assets/1674040985291-d6b8f79e-106f-4de9-a67b-4dc1d6540375-7d385fc0.png",d="/FullStackNotes/assets/1674041077728-48ece357-63a0-467c-b335-d1db69afc886-bdee7bb0.png",p="/FullStackNotes/assets/1674041555641-c0ccf847-be1e-4882-b168-862d9cdcce7a-217fed98.png",u="/FullStackNotes/assets/1674042538948-9435650f-3809-4114-838d-2cef0ed54a2a-be576113.png",m="/FullStackNotes/assets/1674042764260-966d0d5a-e6b3-4119-b449-3fde2466a370-35b0dd63.png",v="/FullStackNotes/assets/1674042873555-548c7b76-8c55-49cc-a61b-3be61d4a6d86-67b50bda.png",k="/FullStackNotes/assets/1674043180233-962ed9f4-773e-4c8b-9658-2adc87a374ce-157e42ec.png",b="/FullStackNotes/assets/1674043621675-24540510-69a7-4130-bdfc-4f7c167bfe73-90a19c80.png",g="/FullStackNotes/assets/1676871692271-1afd24fb-1279-4f0f-b5b2-2861f66713d1-4a004d7a.png",h="/FullStackNotes/assets/1676872012670-528a6e00-35c1-45f3-862f-d16b39448d13-8f236548.png",f="/FullStackNotes/assets/1676872752771-5407ace4-4002-47ef-ae83-2f5b8a966727-9d34f74c.png",A="/FullStackNotes/assets/1676872996481-89f6337c-45f6-42a9-8716-21ea99a344e4-2749f2d6.png",N="/FullStackNotes/assets/image-20230406195636025-93300d6a.png",y="/FullStackNotes/assets/image-20230406200537517-15e2eab3.png",x="/FullStackNotes/assets/1674047922303-b4452544-568e-481c-b8a4-8272d5a153b1-780b1015.png",O="/FullStackNotes/assets/1674048024472-ff0ec242-eea0-4679-9132-423a9028f7a1-44496564.png",I="/FullStackNotes/assets/1674051402479-a53d1fd0-625c-4206-b98c-8f11881811c2-695ed98a.png",q="/FullStackNotes/assets/1674049445308-936302c3-c46b-4b8e-855e-bcf2ac3387fe-64057253.png",T="/FullStackNotes/assets/1674049718897-09c08775-dd51-49b9-bb0a-2e3da4e40b45-bdff5947.png",E="/FullStackNotes/assets/1674049772013-8c2cde2c-b7a4-4e46-915d-ebf851701bf9-21be2540.png",R="/FullStackNotes/assets/1674049811208-ac21384b-571f-4b8d-b9d5-a29b57a9d20b-99f1dfa0.png",S="/FullStackNotes/assets/image-20230530105938295-27b443a4.png",C="/FullStackNotes/assets/image-20230530113300656-e6072c32.png",D="/FullStackNotes/assets/image-20230530110009093-dc726799.png",P="/FullStackNotes/assets/image-20230530134726571-5d3d0f7d.png",w="/FullStackNotes/assets/image-20230530134823163-c3266b9a.png",M="/FullStackNotes/assets/image-20230530134926690-ae29644a.png",L="/FullStackNotes/assets/image-20230530135050542-e1c412c0.png",F="/FullStackNotes/assets/image-20230530135533040-5425b2fd.png",j="data:image/png;base64,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",X="data:image/png;base64,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",G="/FullStackNotes/assets/image-20230530135801100-9ba11358.png",K="/FullStackNotes/assets/image-20230530144047358-cd343526.png",_="/FullStackNotes/assets/image-20230530144156926-1b9398ad.png",Y={},U=a(`<h1 id="docker" tabindex="-1"><a class="header-anchor" href="#docker" aria-hidden="true">#</a> Docker</h1><h2 id="一、安装" tabindex="-1"><a class="header-anchor" href="#一、安装" aria-hidden="true">#</a> 一、安装</h2><h3 id="centos7安装docker" tabindex="-1"><a class="header-anchor" href="#centos7安装docker" aria-hidden="true">#</a> CentOS7安装Docker</h3><p>Docker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10， CentOS 7 满足最低内核的要求，所以我们在CentOS 7安装Docker。</p><h4 id="卸载-可选" tabindex="-1"><a class="header-anchor" href="#卸载-可选" aria-hidden="true">#</a> 卸载（可选）</h4><p>如果之前安装过旧版本的Docker，可以使用下面命令卸载：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>yum remove <span class="token function">docker</span> <span class="token punctuation">\\</span>
                  docker-client <span class="token punctuation">\\</span>
                  docker-client-latest <span class="token punctuation">\\</span>
                  docker-common <span class="token punctuation">\\</span>
                  docker-latest <span class="token punctuation">\\</span>
                  docker-latest-logrotate <span class="token punctuation">\\</span>
                  docker-logrotate <span class="token punctuation">\\</span>
                  docker-selinux <span class="token punctuation">\\</span>
                  docker-engine-selinux <span class="token punctuation">\\</span>
                  docker-engine <span class="token punctuation">\\</span>
                  docker-ce
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="安装docker" tabindex="-1"><a class="header-anchor" href="#安装docker" aria-hidden="true">#</a> 安装Docker</h4><p>首先需要大家虚拟机联网，安装yum工具</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>yum <span class="token function">install</span> <span class="token parameter variable">-y</span> yum-utils <span class="token punctuation">\\</span>
           device-mapper-persistent-data <span class="token punctuation">\\</span>
           lvm2 --skip-broken
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后更新本地镜像源</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 设置docker镜像源</span>
yum-config-manager <span class="token punctuation">\\</span>
    --add-repo <span class="token punctuation">\\</span>
    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
    
<span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">&#39;s/download.docker.com/mirrors.aliyun.com\\/docker-ce/g&#39;</span> /etc/yum.repos.d/docker-ce.repo

yum makecache fast
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>安装Docker</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>yum <span class="token function">install</span> <span class="token parameter variable">-y</span> docker-ce
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>docker-ce为社区免费版本。稍等片刻，docker即可安装成功。</p><h4 id="启动docker" tabindex="-1"><a class="header-anchor" href="#启动docker" aria-hidden="true">#</a> 启动Docker</h4><p>Docker应用需要用到各种端口，逐一去修改防火墙设置。非常麻烦，因此建议大家直接关闭防火墙！</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 关闭</span>
systemctl stop firewalld
<span class="token comment"># 禁止开机启动防火墙</span>
systemctl disable firewalld

<span class="token comment"># 开端口  6379为例</span>
firewall-cmd <span class="token parameter variable">--zone</span><span class="token operator">=</span>public --add-port<span class="token operator">=</span><span class="token number">6379</span>/tcp <span class="token parameter variable">--permanent</span>
<span class="token comment"># 重启防火墙使配置生效</span>
systemctl restart firewalld
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过命令启动docker</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>systemctl start <span class="token function">docker</span>  <span class="token comment"># 启动docker服务</span>

systemctl stop <span class="token function">docker</span>  <span class="token comment"># 停止docker服务</span>

systemctl restart <span class="token function">docker</span>  <span class="token comment"># 重启docker服务</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以查看docker版本</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> <span class="token parameter variable">-v</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="配置镜像加速" tabindex="-1"><a class="header-anchor" href="#配置镜像加速" aria-hidden="true">#</a> 配置镜像加速</h4><p>docker官方镜像仓库网速较差，我们需要设置国内镜像服务：</p>`,24),W={href:"https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors",target:"_blank",rel:"noopener noreferrer"},B=a(`<h3 id="centos安装dockercompose" tabindex="-1"><a class="header-anchor" href="#centos安装dockercompose" aria-hidden="true">#</a> CentOS安装DockerCompose</h3><h4 id="下载" tabindex="-1"><a class="header-anchor" href="#下载" aria-hidden="true">#</a> 下载</h4><p>Linux下需要通过命令下载</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 安装</span>
<span class="token function">curl</span> <span class="token parameter variable">-L</span> https://github.com/docker/compose/releases/download/1.23.1/docker-compose-<span class="token variable"><span class="token variable">\`</span><span class="token function">uname</span> <span class="token parameter variable">-s</span><span class="token variable">\`</span></span>-<span class="token variable"><span class="token variable">\`</span><span class="token function">uname</span> <span class="token parameter variable">-m</span><span class="token variable">\`</span></span> <span class="token operator">&gt;</span> /usr/local/bin/docker-compose
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>也可以手动上传到 /usr/local/bin/ 目录</p><h4 id="修改文件权限" tabindex="-1"><a class="header-anchor" href="#修改文件权限" aria-hidden="true">#</a> 修改文件权限</h4><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 修改权限</span>
<span class="token function">chmod</span> +x /usr/local/bin/docker-compose
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="base自动补全命令" tabindex="-1"><a class="header-anchor" href="#base自动补全命令" aria-hidden="true">#</a> Base自动补全命令</h4><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 补全命令</span>
<span class="token function">curl</span> <span class="token parameter variable">-L</span> https://raw.githubusercontent.com/docker/compose/1.29.1/contrib/completion/bash/docker-compose <span class="token operator">&gt;</span> /etc/bash_completion.d/docker-compose

<span class="token comment"># 如果这里出现错误，需要修改自己的hosts文件</span>
<span class="token builtin class-name">echo</span> <span class="token string">&quot;199.232.68.133 raw.githubusercontent.com&quot;</span> <span class="token operator">&gt;&gt;</span> /etc/hosts
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="二、docker基本操作" tabindex="-1"><a class="header-anchor" href="#二、docker基本操作" aria-hidden="true">#</a> 二、Docker基本操作</h2><h3 id="镜像操作" tabindex="-1"><a class="header-anchor" href="#镜像操作" aria-hidden="true">#</a> 镜像操作</h3><h4 id="镜像名称" tabindex="-1"><a class="header-anchor" href="#镜像名称" aria-hidden="true">#</a> 镜像名称</h4><p>首先来看下镜像的名称组成：</p><ul><li>镜名称一般分两部分组成：[repository]:[tag]。</li><li>在没有指定tag时，默认是latest，代表最新版本的镜像</li></ul><p><img src="`+r+'" alt="image.png"></p><h4 id="镜像命令" tabindex="-1"><a class="header-anchor" href="#镜像命令" aria-hidden="true">#</a> 镜像命令</h4><p>常见的镜像操作命令如图</p><p><img src="'+d+`" alt="image.png"></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 拉取镜像</span>
<span class="token function">docker</span> pull nginx

<span class="token comment"># 查看拉取到的镜像</span>
<span class="token function">docker</span> images

<span class="token comment"># 导出镜像到磁盘 docker save -o [保存的目标文件名称] [镜像名称]</span>
<span class="token function">docker</span> save <span class="token parameter variable">-o</span> nginx.tar nginx:latest

<span class="token comment"># 删除本地的 nginx 镜像</span>
<span class="token function">docker</span> rmi nginx:latest

<span class="token comment"># 加载本地压缩包为镜像</span>
<span class="token function">docker</span> load <span class="token parameter variable">-i</span> nginx.tar

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="容器操作" tabindex="-1"><a class="header-anchor" href="#容器操作" aria-hidden="true">#</a> 容器操作</h3><h4 id="容器相关命令" tabindex="-1"><a class="header-anchor" href="#容器相关命令" aria-hidden="true">#</a> 容器相关命令</h4><p><img src="`+p+`" alt="image.png"></p><p>容器保护三个状态：</p><ul><li>运行：进程正常运行</li><li>暂停：进程暂停，CPU不再运行，并不释放内存</li><li>停止：进程终止，回收进程占用的内存、CPU等资源</li></ul><p>其中：</p><ul><li>docker run：创建并运行一个容器，处于运行状态</li><li>docker pause：让一个运行的容器暂停</li><li>docker unpause：让一个容器从暂停状态恢复运行</li><li>docker stop：停止一个运行的容器</li><li>docker start：让一个停止的容器再次运行</li><li>docker rm：删除一个容器</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 创建并运行nginx容器的命令</span>
<span class="token comment"># --name 给容器起个名 -p 端口映射 -d 后台运行 nginx 镜像名称</span>
<span class="token function">docker</span> run <span class="token parameter variable">--name</span> mynginx <span class="token parameter variable">-p</span> <span class="token number">80</span>:80 <span class="token parameter variable">-d</span> nginx

<span class="token comment"># 进入Nginx容器，修改HTML文件内容，添加“Nginx欢迎您”</span>
<span class="token comment"># -it 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互 bash linux终端交互命令</span>
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> mynginx <span class="token function">bash</span>
<span class="token builtin class-name">cd</span> /usr/share/nginx/html
<span class="token comment"># 容器内没有vi命令，无法直接修改，我们用下面的命令来修改</span>
<span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token parameter variable">-e</span> <span class="token string">&#39;s#Welcome to nginx#Nginx欢迎您#g&#39;</span> <span class="token parameter variable">-e</span> <span class="token string">&#39;s#&lt;head&gt;#&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;#g&#39;</span> index.html
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>容器内部会模拟一个独立的Linux文件系统，看起来如同一个linux服务器一样</p><p><img src="`+u+'" alt="image.png"></p><p>nginx的环境、配置、运行文件全部都在这个文件系统中，包括我们要修改的html文件。</p><p>查看DockerHub网站中的nginx页面，可以知道nginx的html目录位置在/usr/share/nginx/html</p><h3 id="数据卷" tabindex="-1"><a class="header-anchor" href="#数据卷" aria-hidden="true">#</a> 数据卷</h3><p><strong>数据卷（volume）</strong> 是一个虚拟目录，指向宿主机文件系统中的某个目录。</p><p><strong>作用</strong>：将数据与容器解耦，这就要用到数据卷了。</p><p>在之前的nginx案例中，修改nginx的html页面时，需要进入nginx内部。并且因为没有编辑器，修改文件也很麻烦。</p><p>这就是因为容器与数据（容器内文件）耦合带来的后果。</p><p><img src="'+m+'" alt="image.png"></p><p>一旦完成数据卷挂载，对容器的一切操作都会作用在数据卷对应的宿主机目录了。</p><p>这样，我们操作宿主机的/var/lib/docker/volumes/html目录，就等于操作容器内的/usr/share/nginx/html目录了</p><p><img src="'+v+`" alt="image.png"></p><h4 id="数据卷命令" tabindex="-1"><a class="header-anchor" href="#数据卷命令" aria-hidden="true">#</a> 数据卷命令</h4><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> volume <span class="token punctuation">[</span>COMMAND<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>docker volume命令是数据卷操作，根据命令后跟随的command来确定下一步的操作：</p><ul><li>create 创建一个volume</li><li>inspect 显示一个或多个volume的信息</li><li>ls 列出所有的volume</li><li>prune 删除未使用的volume</li><li>rm 删除一个或多个指定的volume</li></ul><h4 id="创建和查看数据卷" tabindex="-1"><a class="header-anchor" href="#创建和查看数据卷" aria-hidden="true">#</a> 创建和查看数据卷</h4><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 创建名为 html 的数据卷</span>
<span class="token function">docker</span> volume create html

<span class="token comment"># 查看所有数据</span>
<span class="token function">docker</span> volume <span class="token function">ls</span>

<span class="token comment"># 查看 html 数据卷详细信息卷</span>
<span class="token function">docker</span> volume inspect html
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+k+`" alt="image.png">可以看到，我们创建的html这个数据卷关联的宿主机目录为/var/lib/docker/volumes/html/_data目录</p><h4 id="挂载数据卷" tabindex="-1"><a class="header-anchor" href="#挂载数据卷" aria-hidden="true">#</a> 挂载数据卷</h4><p>我们在创建容器时，可以通过 -v 参数来挂载一个数据卷到某个容器内目录</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run /
  <span class="token parameter variable">--name</span> mn /
  <span class="token parameter variable">-v</span> html:/root/html /
  <span class="token parameter variable">-p</span> <span class="token number">8080</span>:80
  nginx /
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的-v就是挂载数据卷的命令：</p><ul><li>-v html:/root/htm ：把html数据卷挂载到容器内的/root/html这个目录中</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 创建一个nginx容器，修改容器内的html目录内的index.html内容</span>
<span class="token comment"># 上个案例中，我们进入nginx容器内部，已经知道nginx的html目录所在位置/usr/share/nginx/html ，我们需要把这个目录挂载到html这个数据卷上，方便操作其中的内容</span>

<span class="token comment"># 创建容器并挂载数据卷到容器内的HTML目录</span>
<span class="token function">docker</span> run <span class="token parameter variable">--name</span> mynginx <span class="token parameter variable">-p</span> <span class="token number">80</span>:80 <span class="token parameter variable">-v</span> html:/usr/share/nginx/html <span class="token parameter variable">-d</span> nginx

<span class="token comment"># 进入html数据卷所在位置，并修改HTML内容</span>
<span class="token comment"># 查看html数据卷的位置</span>
<span class="token function">docker</span> volume inspect html
<span class="token comment"># 进入该目录</span>
<span class="token builtin class-name">cd</span> /var/lib/docker/volumes/html/_data
<span class="token comment"># 修改文件</span>
<span class="token function">vi</span> index.html
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>容器不仅仅可以挂载数据卷，也可以直接挂载到宿主机目录上。关联关系如下：</p><ul><li>带数据卷模式：宿主机目录 --&gt; 数据卷 ---&gt; 容器内目录</li><li>直接挂载模式：宿主机目录 ---&gt; 容器内目录</li></ul><p><img src="`+b+'" alt="image.png"></p><p>语法：</p><p>目录挂载与数据卷挂载的语法是类似的：</p><ul><li>-v [宿主机目录]:[容器内目录]</li><li>-v [宿主机文件]:[容器内文件]</li></ul><p><strong>命令比较多，建议使用 CTRL + F 搜索</strong></p><h2 id="三、docker命令汇总" tabindex="-1"><a class="header-anchor" href="#三、docker命令汇总" aria-hidden="true">#</a> 三、Docker命令汇总</h2><p><img src="'+g+`" alt="image.png"></p><p>镜像仓库用来保存镜像，可分为远程镜像仓库和本地镜像仓库。</p><p>通过<code>pull</code>命令可以把远程仓库的镜像下载到本地，通过<code>push</code>命令可以把本地仓库的镜像推送到远程</p><p>本地仓库中的镜像可以用来创建容器，一个镜像可以创建多个容器</p><p>容器也可以通过<code>commit</code>命令打包成镜像，提交到本地仓库。</p><h3 id="操作远程仓库的命令" tabindex="-1"><a class="header-anchor" href="#操作远程仓库的命令" aria-hidden="true">#</a> 操作远程仓库的命令</h3><h4 id="login-登录到远程仓库" tabindex="-1"><a class="header-anchor" href="#login-登录到远程仓库" aria-hidden="true">#</a> login：登录到远程仓库</h4><p>login命令可以登录到远程仓库，登录到远程仓库后可可以拉取仓库的镜像了</p><p><strong>login语法</strong></p><blockquote><p><strong>docker login [OPTIONS] [SERVER]</strong><strong>SERVER</strong>：远程仓库地址，默认为docker官方仓库 <strong>OPTIONS</strong>：</p><ul><li><code>-u</code> string：用户名</li><li><code>-p</code> string：密码</li></ul></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> login <span class="token parameter variable">-u</span> linwei <span class="token parameter variable">-p</span> <span class="token number">123456</span> <span class="token number">192.168</span>.10.10/docker-lib
<span class="token function">docker</span> login <span class="token number">192.168</span>.10.10/docker-lib
<span class="token function">docker</span> login
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="search-从远程仓库搜索镜像" tabindex="-1"><a class="header-anchor" href="#search-从远程仓库搜索镜像" aria-hidden="true">#</a> search：从远程仓库搜索镜像</h4><p><strong>search语法</strong></p><blockquote><p>**docker search [OPTIONS] TERM ** <strong>OPTIONS</strong> ：</p><ul><li><code>-f </code>参数表示根据条件过滤搜索出来的镜像 docker search -f KEY=VALUE TERM</li><li><code>KEY</code><ul><li><code>stars</code> int: 根据热度过滤，如：stars=10表示过滤热度大于10的镜像</li><li><code>is-automated</code> boolean: 根据是否自动构建过滤，如：is-automated=false表示过滤非自动构建的镜像</li><li><code>is-official</code> boolean: 根据是否官方发布过滤，如：is-official=false表示过滤非官方发布的镜像</li></ul></li><li><code> --format</code> 参数用来指定搜索出来的镜像的显示的格式 <ul><li>docker search --format &quot;[table] <code>{{COLUMN}}</code>[<code>{{COLUMN}}</code>...]&quot; TERM</li></ul></li><li><code>COLUMN</code><ul><li>.Name ：显示镜像的名称列</li><li>.Description ：显示镜像的描述列</li><li>.StarCount ：显示镜像的热度一列</li><li>.IsOfficial ：显示镜像是否是官方发布一列</li><li>.IsAutomated ：显示镜像是否是自动构建一列</li></ul></li></ul><p><strong>TERM</strong> ：镜像的关键词</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 搜索centos镜像</span>
<span class="token function">docker</span> search centos
<span class="token comment"># 搜索centos镜像，只展示5个</span>
<span class="token function">docker</span> search <span class="token parameter variable">--limit</span> <span class="token number">5</span> centos
<span class="token comment"># 搜索热度大于100并且不是自动构建的centos镜像</span>
<span class="token function">docker</span> search <span class="token parameter variable">-f</span> <span class="token assign-left variable">stars</span><span class="token operator">=</span><span class="token number">100</span> <span class="token parameter variable">-f</span> is-automated<span class="token operator">=</span>true centos
<span class="token comment"># 搜索非官方发布的centos镜像，搜索结果只展示名称和热度，列之间用TAB键隔开</span>
<span class="token function">docker</span> search <span class="token parameter variable">-f</span> is-official<span class="token operator">=</span>false <span class="token parameter variable">--format</span> <span class="token string">&quot;table{{.Name}}<span class="token entity" title="\\t">\\t</span>{{.StarCount}}&quot;</span> centos
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>search命令可以从远程仓库搜索镜像</p><p><img src="`+h+`" alt="image.png"></p><p>列含义：</p><table><thead><tr><th><strong>NAME</strong></th><th><strong>DESCRIPTION</strong></th><th><strong>STARS</strong></th><th><strong>OFFICIAL</strong></th><th><strong>AUTOMATED</strong></th></tr></thead><tbody><tr><td>镜像名称</td><td>镜像描述</td><td>镜像热度，类似于github的 starts</td><td>是否是官方发布</td><td>是否自动构建</td></tr></tbody></table><h4 id="push-把本地镜像推送到远程仓库" tabindex="-1"><a class="header-anchor" href="#push-把本地镜像推送到远程仓库" aria-hidden="true">#</a> push：把本地镜像推送到远程仓库</h4><p>push可以把本地仓库中的镜像推送到远程仓库，不过需要先登录远程仓库</p><p><strong>push语法</strong></p><blockquote><p><strong>docker push [OPTIONS] NAME[:TAG]</strong><strong>OPTIONS</strong> ：可选参数</p><ul><li><code>--disable-content-trust</code> ：推送时远程仓库不校验签名，默认为true</li></ul><p><strong>NAME</strong> ：镜像名称 <strong>TAG</strong> ：镜像版本号，可省略，默认为latest</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> push my-image:1.1.0
<span class="token function">docker</span> push my-image
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="pull-从远程仓库拉取或更新镜像" tabindex="-1"><a class="header-anchor" href="#pull-从远程仓库拉取或更新镜像" aria-hidden="true">#</a> pull：从远程仓库拉取或更新镜像</h4><p>pull命令可以从远程仓库拉取镜像，如果本地仓库已经存在该镜像，则会更新</p><p><strong>pull语法</strong></p><blockquote><p><strong>docker pull [OPTIONS] NAME[:TAG|@DIGEST]</strong><strong>OPTIONS</strong> ：可选参数</p><ul><li><code>-a</code> : 拉取镜像的所有版本号</li><li><code>--disable-content-trust</code> ：推送时远程仓库不校验签名，默认为 true</li><li><code>-q</code> : 安静模式，推送过程中不展示详细信息</li></ul><p><strong>NAME</strong> ：镜像名称 <strong>TAG</strong> ：镜像版本号，可省略，默认为latest <strong>DIGEST</strong> ： 镜像的摘要，每个镜像都有对应的名称、id、摘要信息，每个摘要信息能唯一代表一个镜像</p></blockquote><p><img src="`+f+`" alt="image.png"></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> pull centos
<span class="token function">docker</span> pull <span class="token parameter variable">-q</span> centos:5.11
<span class="token function">docker</span> pull <span class="token parameter variable">-a</span> <span class="token parameter variable">-q</span> centos
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="操作本地镜像的命令" tabindex="-1"><a class="header-anchor" href="#操作本地镜像的命令" aria-hidden="true">#</a> 操作本地镜像的命令</h3><h4 id="images-显示所有镜像" tabindex="-1"><a class="header-anchor" href="#images-显示所有镜像" aria-hidden="true">#</a> images：显示所有镜像</h4><p>images命令可以显示本地存在的所有镜像</p><p><strong>images语法</strong></p><blockquote><p><strong>docker images [OPTIONS] [REPOSITORY[:TAG]]</strong><strong>OPTIONS</strong> ：可选参数</p><ul><li><code>-a</code> : 显示所有镜像，包含中间映像（默认情况下中间映像是隐藏的）</li><li><code>-f</code> filter: 根据条件过滤镜像 <ul><li>docker images -f KEY=VALUE [REPOSITORY[:TAG]]</li><li>KEY： <ul><li><code>dangling</code> boolean：过滤悬挂的镜像，如：dangling=true表示只显示悬挂的镜像</li><li><code>label</code> string: 根据标签过滤，如：label=version表示显示有version标签的镜像，label=version=1.0 表示显示version=1.0的镜像</li><li><code>before</code> image: 显示在某个镜像之前创建的镜像，如： before=centos:5.8表示显示在centos:5.8这个镜像之前创建的镜像</li><li><code>since</code> image: 显示在某个 存在之后创建的镜像，如：since=centos:5.8表示显示在centos:5.8这个镜像存在之后的镜像</li><li><code>reference</code> string：模糊匹配，如：reference=cent:5, 显示名称已cent开头版本号已5开头的 镜像</li></ul></li></ul></li><li><code>-q</code> : 只显示镜像id</li><li><code>no-trunc</code> ：显示完整的镜像id。默认情况下，镜 像的id只显示前12位，no-trunc参数会将镜像id完整的显示出来</li><li><code>--digests</code> ：显示镜像的摘要 信息</li><li><code>--format</code> string: 指定镜像显示的格式，格式详见下文 <ul><li>docker images --format &quot;[table] <code>{{COLUMN}}</code>[<code>{{COLUMN}}</code>...]&quot; [REPOSITORY[:TAG]]</li><li><code>COLUMN</code>: <ul><li><code> .ID</code> ：显示镜像的名称列</li><li><code>.Repository</code> ：显示镜像的描述列</li><li><code>.Tag</code> ：显示镜像的热度一列</li><li><code>.Digest</code> ：显示镜像是否是官方发布一列</li><li><code>.CreatedSince</code> ：显示镜像是否是自动构建一列</li><li><code>.CreatedAt</code> ：显示镜像是否是自动构建一列</li><li><code>.Size</code> ：显示镜像是否是自动构建一列</li></ul></li></ul></li></ul><p><strong>REPOSITORY</strong> ：镜像路径 <strong>TAG</strong> ：镜像版本</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 显示本地所有镜像</span>
<span class="token function">docker</span> images
<span class="token comment"># 显示本地所有镜像，只显示id列并且不截断</span>
<span class="token function">docker</span> images <span class="token parameter variable">-q</span> --no-trunc
<span class="token comment"># 显示centos镜像信息</span>
<span class="token function">docker</span> images centos
<span class="token comment"># 显示列中包含cent关键字的所有镜像</span>
<span class="token function">docker</span> images <span class="token operator">|</span> <span class="token function">grep</span> cent
<span class="token comment"># 显示本地所有镜像，并显示摘要列</span>
<span class="token function">docker</span> images <span class="token parameter variable">--digests</span>
<span class="token comment"># 显示在cengos:latest镜像之后创建的latest版本的所有镜像</span>
<span class="token function">docker</span> images <span class="token parameter variable">-f</span> <span class="token assign-left variable">since</span><span class="token operator">=</span>centos:latest <span class="token parameter variable">-f</span> <span class="token assign-left variable">reference</span><span class="token operator">=</span>*:latest
<span class="token comment"># 显示所有镜像信息，只显示镜像id、摘要、创建时间3列，列之间用TAB键隔开</span>
<span class="token function">docker</span> images <span class="token parameter variable">--format</span> <span class="token string">&quot;table {{.ID}}<span class="token entity" title="\\t">\\t</span>{{.Digest}}<span class="token entity" title="\\t">\\t</span>{{.CreatedAt}}&quot;</span>
<span class="token comment"># 显示在centos:5.11镜像之前创建的镜像，只显示镜像仓库路径、版本号、创建时间3列，列之间用TAB键隔开</span>
<span class="token function">docker</span> images <span class="token parameter variable">-f</span> <span class="token assign-left variable">before</span><span class="token operator">=</span>centos:5.11 <span class="token parameter variable">--format</span> <span class="token string">&quot;table {{.Repository}}<span class="token entity" title="\\t">\\t</span>{{.Tag}}<span class="token entity" title="\\t">\\t</span>{{.CreatedAt}}&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="`+A+`" alt="image.png"></p><p>列含义：</p><table><thead><tr><th><strong>REPOSITORY</strong></th><th><strong>TAG</strong></th><th><strong>IMAGE ID</strong></th><th><strong>CREATED</strong></th><th><strong>SIZE</strong></th></tr></thead><tbody><tr><td>仓库路径</td><td>镜像版本</td><td>镜像id</td><td>创建时间</td><td>镜像大小</td></tr></tbody></table><h4 id="rmi-删除本地镜像" tabindex="-1"><a class="header-anchor" href="#rmi-删除本地镜像" aria-hidden="true">#</a> rmi：删除本地镜像</h4><p>rmi命令可以删除一个或多个本地镜像，通常情况应该用rm表示删除命令，但是在doker命令中rm 表示删除容 器，所以用rmi表示删除镜像，其中的 i 是image的首字母</p><p><strong>rmi语法</strong></p><blockquote><p><strong>docker rmi [OPTIONS] IMAGE [IMAGE...]</strong><strong>OPTIONS</strong> ：可选参数</p><ul><li><code>-f </code>: 强制删除，如果镜像有对应的容器正在运行，则不允许直接删除镜像，需要强制删除</li><li><code>-- no-prune</code> ：不删除该镜像的过程镜像，默认是删除的</li></ul><p><strong>IMAGE</strong> ：镜像id或仓库路径名称</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 删除centos镜像</span>
<span class="token function">docker</span> rmi tomcat
<span class="token comment"># 删除centos:5.11镜像</span>
<span class="token function">docker</span> rmi centos:5.11
<span class="token comment"># 删除id为621ceef7494a的镜像</span>
<span class="token function">docker</span> rmi 621ceef7494a
<span class="token comment"># 同时删除tomcat、centos和redis镜像</span>
<span class="token function">docker</span> rmi tomcat centos redis
<span class="token comment"># 强制删除tomcat镜像，就算此时有tomcat容器正在运行，镜像也会被删除</span>
<span class="token function">docker</span> rmi <span class="token parameter variable">-f</span> tomcat
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="tag-标记镜像-将其归入仓库" tabindex="-1"><a class="header-anchor" href="#tag-标记镜像-将其归入仓库" aria-hidden="true">#</a> tag：标记镜像，将其归入仓库</h4><p><code>tag</code>命令可以基于一个镜像，创建一个新版本的镜像并归入本地仓库，此时该镜像在仓库中存在两个 版本，可以 根据这两个镜像创建不同的容器</p><p><strong>tag语法</strong></p><blockquote><p><strong>docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]</strong><strong>SOURCE_IMAGE</strong> : 原镜像 <strong>TARGET_IMAGE</strong> ：新镜像 <strong>TAG</strong> ：镜像的版本号</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 基于redis:latest镜像创建my-redis1.0镜像，并把新镜像归入redis-lib仓库</span>
<span class="token function">docker</span> tag redis:latest redis-lib/my-redis:1.0
<span class="token comment"># 基于621ceef7494a镜像创建my-redis:test-100m镜像，并把新镜像归入redis-lib仓库</span>
<span class="token function">docker</span> tag 621ceef7494a redis-lib/my-redis:test-100m
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="history-查看镜像的创建历史" tabindex="-1"><a class="header-anchor" href="#history-查看镜像的创建历史" aria-hidden="true">#</a> history：查看镜像的创建历史</h4><p>history命令用来查看某一个镜像的创建历史，也就是镜像的提交记录</p><p><strong>history语法</strong></p><blockquote><p><strong>docker history [OPTIONS] IMAGE</strong><strong>OPTIONS</strong> ：可选参数</p><ul><li><code>-H</code> boolean: 已可读的格式打印日期和大小，默认为true</li><li><code>-q</code> : 只显示镜像id</li><li><code>no-trunc</code> ：输出 结果不截取，正常情况下查看到的结果如果某一列太长会被截取</li><li><code>--format</code> string: 指定镜像显示的格式 <ul><li>docker history --format &quot;[table] <code>{{COLUMN}}</code>[<code>{{COLUMN}}</code>...]&quot; IMAGE</li><li><code>COLUMN</code><ul><li><code>.ID </code>：镜像的ID</li><li><code>.CreatedSince</code> ：镜像创建的时长</li><li><code>.CreatedAt</code> ：镜像创建的时间戳</li><li><code>.CreatedBy</code> ：镜像创建使用的命令</li><li><code> .Size</code> ：镜像的大小</li><li><code> .Comment</code> ：镜像的评论</li></ul></li></ul></li></ul><p><strong>IMAGE</strong> ：镜像</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 显示centos镜像的创建历史</span>
<span class="token function">docker</span> <span class="token function">history</span> centos
<span class="token comment"># 显示centos镜像的创建历史，时间和大小转换为人类可读的格式</span>
<span class="token function">docker</span> <span class="token function">history</span> <span class="token parameter variable">-H</span><span class="token operator">=</span>true centos
<span class="token comment"># 显示centos镜像的创建历史，只显示ID、创建时间戳和创建时的命令3列，列之间使用TAB键隔开</span>
<span class="token function">docker</span> <span class="token function">history</span> <span class="token parameter variable">--format</span> <span class="token string">&quot;table {{.ID}}<span class="token entity" title="\\t">\\t</span>{{.CreatedAt}}<span class="token entity" title="\\t">\\t</span>{{.CreatedBy}}&quot;</span> centos
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="save-将镜像打包成文件" tabindex="-1"><a class="header-anchor" href="#save-将镜像打包成文件" aria-hidden="true">#</a> save：将镜像打包成文件</h4><p>save命令可以把一个镜像或多个镜像打包到一个文件中，需要特别注意和export命令的区分</p><ul><li>save命令打包的是镜像，包含镜像的所有信息</li><li>exprot命令打包的是容器，只是保存容器当时的快照，历史记录和元数据信息将会丢失</li></ul><p><strong>save语法</strong></p><blockquote><p><strong>docker save [OPTIONS] IMAGE [IMAGE...]</strong><strong>OPTIONS</strong> ：可选参数</p><ul><li><code>-o</code> string: 指定目标文件，和linux原生命令 &gt; 有相同作用</li></ul><p><strong>IMAGE</strong> ：镜像</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 将centos镜像打包成my-images.tar</span>
<span class="token function">docker</span> save centos <span class="token operator">&gt;</span> /home/my-images.tar
<span class="token comment"># 将centos镜像和redis镜像打包到my-images.tar</span>
<span class="token function">docker</span> save centos redis <span class="token operator">&gt;</span> /home/my-images.tar
<span class="token comment"># 将centos镜像和redis镜像打包到my-images.tar</span>
<span class="token function">docker</span> save <span class="token parameter variable">-o</span> /home/my-images.tar centos redis
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="load-从指定文件中加载镜像" tabindex="-1"><a class="header-anchor" href="#load-从指定文件中加载镜像" aria-hidden="true">#</a> load：从指定文件中加载镜像</h4><p>load命令可以从指定文件中加载镜像，该文件需要是save命令保存的文件</p><p><strong>load语法</strong></p><blockquote><p><strong>docker load [OPTIONS]</strong><strong>OPTIONS</strong> ：可选参数</p><ul><li><code>-i</code> string: 指定文件的路径</li><li><code>-q</code> ：安静模式输出</li></ul></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 从my-images.tar文件中加载镜像</span>
<span class="token function">docker</span> load <span class="token operator">&lt;</span> /home/my-images.tar
<span class="token comment"># 从my-images.tar文件中加载镜像</span>
<span class="token function">docker</span> load <span class="token parameter variable">-i</span> /home/my-images.tar
<span class="token comment"># 使用安静模式从my-images.tar文件中加载镜像</span>
<span class="token function">docker</span> load <span class="token parameter variable">-i</span> /home/my-images.tar <span class="token parameter variable">-q</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="操作容器的命令" tabindex="-1"><a class="header-anchor" href="#操作容器的命令" aria-hidden="true">#</a> 操作容器的命令</h3><h4 id="run-创建一个容器并运行" tabindex="-1"><a class="header-anchor" href="#run-创建一个容器并运行" aria-hidden="true">#</a> run：创建一个容器并运行</h4><p>run命令可以创建一个容器并运行，如果创建容器的镜像不存在则会从远程镜像仓库下载</p><p>运行容器的同时还能给容器发送一个命令</p><p><strong>run语法</strong></p><blockquote><p><strong>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</strong><strong>OPTIONS</strong> ：可选参数</p><ul><li><code>-i </code>: 以交互模式运行，通常与<code>-t</code>一起使用</li><li><code>-t</code> : 为容器分配一个伪终端，通常与<code>-i</code>一起使用</li><li><code>-d</code> : 后台模式运行容器，并返回容器id</li><li><code>-p</code> list: 指定端口映射，格式为 <code>宿主机端口:容器端口</code></li><li><code>-P</code> : 随机分配端口映射</li><li><code>--name</code> string: 给容器指定一个名称</li><li><code>-m</code> bytes: 限制容器可以使用的内存大 小，单位可选b、k、m、g</li><li><code>-v</code> list: 把宿主机的磁盘路径挂载到容器的某个路径</li><li><code>--volumes-from</code> list: 绑定别的容器某个路径到此容器的某个路径</li><li><code>-w</code> : 指定容器的工作目录，默认是根目录</li><li><code>--rm</code> : 当容器停止运行时自动删除</li><li><code>--hostname</code> string: 指定容器的主机名</li></ul><p><strong>IMAGE</strong> ：镜像 <strong>COMMAND</strong> ：需要运行的命令 <strong>ARG</strong> ：命令的参数</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 创建一个centos容器，并运行</span>
<span class="token function">docker</span> run centos
<span class="token comment"># 创建一个centos容器，并以交互模式运行</span>
<span class="token function">docker</span> run <span class="token parameter variable">-it</span> centos
<span class="token comment"># 创建一个centos容器，并后台模式运行</span>
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> centos
<span class="token comment"># 创建一个centos容器，重命名为my-centos，并以交互模式运行，并在容器中运行bash命令</span>
<span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--name</span> my-centos centos /bin/bash
<span class="token comment"># 创建一个spring-boot容器并以交互模式运行，容器重命名为my-boot，并把主机的80端口映射到容</span>
<span class="token comment"># 器的8080端口，此时访问主机ip+80端口即可访问容器中的sping-boot项目</span>
<span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--name</span> my-boot <span class="token parameter variable">-p</span> <span class="token number">80</span>:8080 spring-boot
<span class="token comment"># 创建一个spring-boot容器并以交互模式运行，容器重命名为my-boot，并把主机/logs/my-boot/的</span>
<span class="token comment"># 目录绑定到容器的/logs目录，此时my-boot项目的日志可以在主机的/logs/my-boot目录中查看</span>
<span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--name</span> my-boot <span class="token parameter variable">-v</span> /logs/my-boot/:/logs/ spring-boot
<span class="token comment"># 创建一个spring-boot容器并以交互模式运行，容器重命名为my-boot；把主机的80端口映射到容器</span>
<span class="token comment"># 的8080端口；把主机/logs/my-boot/的路径绑定到容器的/logs目录；给容器分配最大500M的内</span>
<span class="token comment"># 存；指定spring-boot的配置文件为test</span>
<span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--name</span> my-boot <span class="token parameter variable">-p</span> <span class="token number">80</span>:8080 <span class="token parameter variable">-v</span> /logs/my-boot/:/logs/ <span class="token parameter variable">-m</span> 500M spring-boot <span class="token parameter variable">--spring.profiles.active</span><span class="token operator">=</span>test
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="start-启动容器" tabindex="-1"><a class="header-anchor" href="#start-启动容器" aria-hidden="true">#</a> start：启动容器</h4><p>start命令可以启动一个或多个已经停止的容器</p><p><strong>start语法</strong></p><blockquote><p>docker start [OPTIONS] CONTAINER [CONTAINER...]</p><p><strong>OPTIONS</strong> ：可选参数</p><ul><li>-<code>a</code> : 将容器的标准输出或标准错误附加到终端</li><li><code>-i</code> : 为容器附加一个标准输入终端</li></ul><p><strong>CONTAINER</strong> ：容器</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 启动已经停止的tomcat容器</span>
<span class="token function">docker</span> start tomcat
<span class="token comment"># 启动已经停止的tomcat和centos容器</span>
<span class="token function">docker</span> start tomcat centos
<span class="token comment"># 启动已经停止的my-spring-boot容器，并输出日志</span>
<span class="token function">docker</span> start <span class="token parameter variable">-a</span> my-spring-boot
<span class="token comment"># 启动已经停止centos容器，并附加一个输入终端</span>
<span class="token function">docker</span> start <span class="token parameter variable">-i</span> centos
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="restart-重启容器" tabindex="-1"><a class="header-anchor" href="#restart-重启容器" aria-hidden="true">#</a> restart：重启容器</h4><p>restart可以对一个或多个容器进行重启。</p><p>如果容器是未启动的则会启动，如果是正在运行中的，则 会重启</p><p><strong>restart语法</strong></p><blockquote><p>docker restart [OPTIONS] CONTAINER [CONTAINER...]</p><p><strong>OPTIONS</strong> ：可选参数</p><ul><li><code>-t</code> int: 在重启之前等待几秒，默认10秒</li></ul><p><strong>CONTAINER</strong> ：容器</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 重启centos容器</span>
<span class="token function">docker</span> restart centos
<span class="token comment"># 20秒之后重启centos和tomcat容器，如果20秒内还未停止则直接杀死然后重启</span>
<span class="token function">docker</span> restart <span class="token parameter variable">-t</span> <span class="token number">20</span> centos tomcat
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="stop-停止容器" tabindex="-1"><a class="header-anchor" href="#stop-停止容器" aria-hidden="true">#</a> stop：停止容器</h4><p><code>stop</code>命令可以停止一个或多个正在运行的容器</p><p><code>kill</code>命令也可以用来停止容器</p><p>不同的是：</p><ul><li><code>stop</code>命令允许容器在停止之前有一定的时间来进行额外操作，如释放链接、关闭请求等</li><li><code>kill</code>命令则会直接强制杀死容器</li></ul><p><strong>stop语法</strong></p><blockquote><p>docker stop [OPTIONS] CONTAINER [CONTAINER...]</p><p><strong>OPTIONS</strong> ：可选参数</p><ul><li><code>-t</code> int: 等待n秒后如果还没停止，直接杀死，默认10秒</li></ul><p><strong>CONTAINER</strong> ：容器</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 停止tomcat容器</span>
<span class="token function">docker</span> stop tomcat
<span class="token comment"># 停止tomcat和centos容器</span>
<span class="token function">docker</span> stop tomcat centos
<span class="token comment"># 停止tomcat容器，如果5秒内还未停止则直接杀死</span>
<span class="token function">docker</span> stop <span class="token parameter variable">-t</span> <span class="token number">5</span> tomcat
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="kill-杀死容器" tabindex="-1"><a class="header-anchor" href="#kill-杀死容器" aria-hidden="true">#</a> kill：杀死容器</h4><p>kill命令可以杀死一个或多个正在运行的容器</p><p><strong>kill语法</strong></p><blockquote><p>docker kill [OPTIONS] CONTAINER [CONTAINER...]</p><p><strong>OPTIONS</strong> ：可选参数</p><ul><li><code>-s</code> string: 给容器发送一个信号，信号编号和<code>linux</code>原生命令<code>kill</code>的信号编号一致，默认值9 <ul><li><code>1</code> ：杀死并重新加载，也可用 <code>HUP</code> 表示</li><li><code>9</code> ：强制杀死，也可用 <code>KILL</code> 表示，默认值</li><li><code>15</code> ：正 常停止，也可用 <code>TERM</code> 表示</li></ul></li></ul><p><strong>CONTAINER</strong> ：容器</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 杀死tomcat容器</span>
<span class="token function">docker</span> <span class="token function">kill</span> tomcat
<span class="token comment"># 强制杀死tomcat容器</span>
<span class="token function">docker</span> <span class="token function">kill</span> <span class="token parameter variable">-s</span> <span class="token number">9</span> tomcat
<span class="token comment"># 强制杀死tomcat容器</span>
<span class="token function">docker</span> <span class="token function">kill</span> <span class="token parameter variable">-s</span> KILL tomcat
<span class="token comment"># 杀死tomcat和centos容器</span>
<span class="token function">docker</span> <span class="token function">kill</span> tomcat centos
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="rm-删除容器" tabindex="-1"><a class="header-anchor" href="#rm-删除容器" aria-hidden="true">#</a> rm：删除容器</h4><p><code>rm</code>命令可以删除一个或多个容器 如果容器正在运行，则需要通过<code>-f</code>参数强制删除</p><p><strong>rm语法</strong></p><blockquote><p>docker rm [OPTIONS] CONTAINER [CONTAINER...]</p><p><strong>OPTIONS</strong> ：可选参数</p><ul><li><code>-f</code> ：强制删除，即使容器正在运行也可以删除</li><li><code>-l</code> ：删除容器之间的网络关系，而不是容器本 身</li><li><code>-v</code> : 删除容器和它挂载的卷</li></ul><p><strong>CONTAINER</strong> ：容器</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 删除centos容器</span>
<span class="token function">docker</span> <span class="token function">rm</span> centos
<span class="token comment"># 强制删除centos容器，即使容器正在运行也会被删除</span>
<span class="token function">docker</span> <span class="token function">rm</span> <span class="token parameter variable">-f</span> centos
<span class="token comment"># 删除centos容器，并删除它挂载的卷</span>
<span class="token function">docker</span> <span class="token function">rm</span> <span class="token parameter variable">-f</span> centos
<span class="token comment"># 删除所有已经停止的容器</span>
<span class="token function">docker</span> <span class="token function">rm</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> <span class="token function">ps</span> <span class="token parameter variable">-a</span> <span class="token parameter variable">-q</span><span class="token variable">)</span></span>
<span class="token comment"># 移除容器my-nginx对容器my-db的连接，连接名db</span>
<span class="token function">docker</span> <span class="token function">rm</span> <span class="token parameter variable">-l</span> db 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="pause-暂停容器" tabindex="-1"><a class="header-anchor" href="#pause-暂停容器" aria-hidden="true">#</a> pause：暂停容器</h4><p>pause命令可以暂停一个或多个正在运行的容器</p><p><strong>pause语法</strong></p><blockquote><p>docker pause CONTAINER [CONTAINER...]</p><p><strong>CONTAINER</strong> ：容器</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 暂停正在运行的centos容器</span>
<span class="token function">docker</span> pause centos
<span class="token comment"># 暂停正在运行的centos和tomcat容器</span>
<span class="token function">docker</span> pause centos tomcat
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="unpause-取消暂停容器" tabindex="-1"><a class="header-anchor" href="#unpause-取消暂停容器" aria-hidden="true">#</a> unpause：取消暂停容器</h4><p><code>unpause</code>命令可以对一个或多个暂停的容器取消暂停</p><p><strong>pause语法</strong></p><blockquote><p>docker unpause CONTAINER [CONTAINER...]</p><p><strong>CONTAINER</strong> ：容器</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 取消暂停的centos容器</span>
<span class="token function">docker</span> unpause centos
<span class="token comment"># 取消暂停centos和tomcat容器</span>
<span class="token function">docker</span> unpause centos tomcat
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="create-创建一个容器" tabindex="-1"><a class="header-anchor" href="#create-创建一个容器" aria-hidden="true">#</a> create：创建一个容器</h4><p><code>create</code>命令可以创建一个容器，但不运行它</p><p>在需要的时候可以使用<code>start</code>命令启动 和<code>run</code>命令的用法几乎一致，都会创建一个容器，如果容器依赖的镜像不存在都会从远程仓库拉取</p><p><code>run</code>命令创建容器后会运行容器</p><p><code>create</code>命令只是创建容器，不运行</p><p><strong>create语法</strong></p><blockquote><p>docker create [OPTIONS] IMAGE [COMMAND] [ARG...]</p><p><strong>OPTIONS</strong> ：可选参数</p><ul><li><code>create</code>命令和<code>run</code>命令的可选参数一样</li></ul><p><strong>IMAGE</strong> ：镜像</p><p><strong>COMMAND</strong> ：需要运行的命令</p><p><strong>ARG</strong> ：命令的参数</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 创建一个centos容器</span>
<span class="token function">docker</span> create centos
<span class="token comment"># 创建一个centos容器，start启动时以交互模式运行</span>
<span class="token function">docker</span> create <span class="token parameter variable">-it</span> centos
<span class="token comment"># 创建一个centos容器，start启动时后台模式运行</span>
<span class="token function">docker</span> create <span class="token parameter variable">-d</span> centos
<span class="token comment"># 创建一个centos容器，重命名为my-centos，start时以交互模式运行，并在容器中运行bash命令</span>
<span class="token function">docker</span> create <span class="token parameter variable">-it</span> <span class="token parameter variable">--name</span> my-centos centos /bin/bash

<span class="token comment"># 创建一个spring-boot容器，重命名为my-boot，并把主机的80端口映射到容器的8080端口，start</span>
<span class="token comment"># 时以交互模式运行，此时访问主机ip+80端口即可访问容器中的sping-boot项目</span>
<span class="token function">docker</span> create <span class="token parameter variable">-it</span> <span class="token parameter variable">--name</span> my-boot <span class="token parameter variable">-p</span> <span class="token number">80</span>:8080 spring-boot

<span class="token comment"># 创建一个spring-boot容器，容器重命名为my-boot，并把主机/logs/my-boot/的目录绑定到容器</span>
<span class="token comment"># 的/logs目录，start时以交互模式运行，此时my-boot项目的日志可以在主机的/logs/my-boot目录</span>
<span class="token comment"># 中查看</span>
<span class="token function">docker</span> create <span class="token parameter variable">-it</span> <span class="token parameter variable">--name</span> my-boot <span class="token parameter variable">-v</span> /logs/my-boot/:/logs/ spring-boot

<span class="token comment"># 创建一个spring-boot容器，容器重命名为my-boot；把主机的80端口映射到容器的8080端口；把</span>
<span class="token comment"># 主机/logs/my-boot/的路径绑定到容器的/logs目录；给容器分配最大500M的内存；指定spring-boot的配置文件为test；# start时以交互模式运行</span>
<span class="token function">docker</span> create <span class="token parameter variable">-it</span> <span class="token parameter variable">--name</span> my-boot <span class="token parameter variable">-p</span> <span class="token number">80</span>:8080 <span class="token parameter variable">-v</span> /logs/my-boot/:/logs/ <span class="token parameter variable">-m</span> 500M spring-boot <span class="token parameter variable">--spring.profiles.active</span><span class="token operator">=</span>test
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="exec-在容器中执行命令" tabindex="-1"><a class="header-anchor" href="#exec-在容器中执行命令" aria-hidden="true">#</a> exec：在容器中执行命令</h4><p>exce命令可以在一个运行中的容器中执行一个命令</p><p><strong>exec语法</strong></p><blockquote><p>docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</p><p><strong>OPTIONS</strong> ：可选参数</p><ul><li><code>-d</code> : 命令在后台运行</li><li>-i ：保持标准输入，通常和 <code>-t</code> 一起使用</li><li><code>-t</code> : 分配一个伪终端，通常和 <code>- i</code> 一起使用</li><li><code>-w</code> string: 指定容器的路径</li></ul><p><strong>CONTAINER</strong> ：容器</p><p><strong>COMMAND</strong> ：要执行的命令</p><p><strong>ARG</strong> ：命令的参数</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 在centos容器中运行pwd命令</span>
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> centos <span class="token builtin class-name">pwd</span>
<span class="token comment"># 为centos容器分配一个输入终端</span>
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> centos /bin/bash
<span class="token comment"># 在centos镜像中的bin目录执行ls命令</span>
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-w</span> /bin centos <span class="token function">ls</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="ps-查看容器列表" tabindex="-1"><a class="header-anchor" href="#ps-查看容器列表" aria-hidden="true">#</a> ps：查看容器列表</h4><p>ps命令可以列出所有容器的列表，查看容器的基本信息。</p><p>不加任何参数的情况下，默认只展示正在运行的容器</p><p><img src="`+N+`" alt="image-20230406195636025"></p><p>列含义如下</p><table><thead><tr><th>CONTAINER ID</th><th>IMAGE</th><th>COMMAND</th><th>CREATED</th><th>PORTS</th><th>NAMES</th></tr></thead><tbody><tr><td>容器id</td><td>对应的镜 像</td><td>容器启动时运行的 命令</td><td>创建时间</td><td>绑定的的端 口</td><td>容器名 称</td></tr></tbody></table><p><strong>ps语法</strong></p><blockquote><p>docker ps [OPTIONS]</p><p><strong>OPTIONS</strong> ：可选参数</p><ul><li><p><code>-a</code> : 显示所有容器，默认只显示正在运行的</p></li><li><p><code>-f</code> filter: 根据条件过滤容器，语法如下</p><ul><li>docker ps -f KEY=VALUE</li><li>KEY的可选值如下 <ul><li><code>id</code> : 根据容器id过滤</li><li><code>name</code> : 查看容器名称中包含给定字段的容器</li><li><code>exited</code> : 根据容器退出的错 误码进行过滤</li><li><code>status</code> : 根据容器的状态进行过滤，状态可选值有：created、paused、 exited、dead、running、restarting、removing</li><li><code>before</code> : 只显示在某个容器之前创建的容器</li><li><code>since</code> : 只显示在某个容器之后创建的容器</li><li><code>volume</code> : 过滤绑定了某个目录的容器，只针对运行 中的容器</li><li><code>publish</code> : 根据宿主机端口过滤，只针对运行中的容器</li><li><code>expose</code> : 根据容器端口过滤，只针对运行中的容器</li></ul></li></ul></li><li><p><code>-n</code> int：显示最后创建的n个容器，包含所有状态</p></li><li><p><code>-l</code> : 显示最新创建的容器，包含所有状态</p></li><li><p><code>-q</code> : 只显示容器id</p></li><li><p><code>-s</code> : 显示容器大小，默认不显示该列</p></li><li><p><code>--no-trunc</code> ：显示内容不截断，默认情 况下显示的容器是截断后的信息</p></li></ul></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 查看运行中的容器</span>
<span class="token function">docker</span> <span class="token function">ps</span>
<span class="token comment"># 查看所有容器</span>
<span class="token function">docker</span> <span class="token function">ps</span> <span class="token parameter variable">-a</span>
<span class="token comment"># 查看所有容器，并显示容器大小</span>
<span class="token function">docker</span> <span class="token function">ps</span> <span class="token parameter variable">-a</span> <span class="token parameter variable">-s</span>
<span class="token comment"># 查看所有容器，显示内容不截断</span>
<span class="token function">docker</span> <span class="token function">ps</span> <span class="token parameter variable">-a</span> --no-trunc
<span class="token comment"># 查看容器名称中包含cent的容器</span>
<span class="token function">docker</span> <span class="token function">ps</span> <span class="token parameter variable">-f</span> <span class="token assign-left variable">name</span><span class="token operator">=</span>cent
<span class="token comment"># 查看状态是created的容器</span>
<span class="token function">docker</span> <span class="token function">ps</span> <span class="token parameter variable">-f</span> <span class="token assign-left variable">status</span><span class="token operator">=</span>created
<span class="token comment"># 查看在centos之前创建的容器</span>
<span class="token function">docker</span> <span class="token function">ps</span> <span class="token parameter variable">-f</span> <span class="token assign-left variable">before</span><span class="token operator">=</span>centos
<span class="token comment"># 查看绑定了宿主机80端口并且正在运行的容器</span>
<span class="token function">docker</span> <span class="token function">ps</span> <span class="token parameter variable">-f</span> <span class="token assign-left variable">publish</span><span class="token operator">=</span><span class="token number">80</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="inspect-获取容器或镜像的元数据" tabindex="-1"><a class="header-anchor" href="#inspect-获取容器或镜像的元数据" aria-hidden="true">#</a> inspect：获取容器或镜像的元数据</h4><p><code>inspect</code>命令可以获取一个或多个容器或者镜像的元数据信息</p><p>元数据信息可以理解为容器或者镜像的详情，它比 <code>ps</code> 命令显示的内容要详细的多。</p><p>比如说端口映 射、挂载目录等，显示格式为<code>json</code>类型</p><p><strong>inspect语法</strong></p><blockquote><p>docker inspect [OPTIONS] CONTAINER|IMAGE [CONTAINER|IMAGE...]</p><p><strong>OPTIONS</strong> ：可选参数</p><p><code>-f</code> string: 格式化输出结果，inspect默认显示整个文件的详情，-f参数可以指定只显示某些属 性</p><p><code>--s</code> : 只对容器有效，显示容器的配置文件行数和大小，显示的结果中会多出<code>SizeRw</code>、 <code>SizeRootFs</code>两个参数</p><p><code>--type</code> string: 指定要inspect的类型，container表示容器，image表示 镜像，默认是容器。</p><p>比如我有一个tomcat镜像，同时有一个名称为tomcat的容器，就可以用-- type参数来指定要inspect是tomcat容器还是tomcat镜像</p><p><strong>CONTAINER</strong> ：容器</p><p><strong>IMAGE</strong> ：镜像</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 查看tomcat容器的元数据信息</span>
<span class="token function">docker</span> inspect tomcat
<span class="token comment"># 查看tomcat镜像的元数据信息</span>
<span class="token function">docker</span> inspect <span class="token parameter variable">--type</span><span class="token operator">=</span>image tomcat
<span class="token comment"># 查看tomcat容器的ip地址</span>
<span class="token function">docker</span> inspect <span class="token parameter variable">--format</span><span class="token operator">=</span><span class="token string">&#39;{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}&#39;</span>
tomcat
<span class="token comment"># 查看tomcat容器的ip地址</span>
<span class="token function">docker</span> inspect tomcat <span class="token operator">|</span> <span class="token function">grep</span> IPAddress
<span class="token comment"># 查看tomcat容器的端口映射</span>
<span class="token function">docker</span> inspect <span class="token parameter variable">-f</span> <span class="token string">&quot;{{.HostConfig.PortBindings}}&quot;</span> tomcat
<span class="token comment"># 查看tomcat容器的挂载目录</span>
<span class="token function">docker</span> inspect <span class="token parameter variable">-f</span> <span class="token string">&quot;{{.HostConfig.Binds}}&quot;</span> tomcat
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="stats-监控容器的资源使用情况" tabindex="-1"><a class="header-anchor" href="#stats-监控容器的资源使用情况" aria-hidden="true">#</a> stats：监控容器的资源使用情况</h4><p><code>stats</code>命令可以可以监控容器的资源使用情况，如<code>cpu</code>使用情况、内存使用情况等。</p><p>每秒刷新一次， 直到使用 <code>ctrl+c</code> 退出</p><p><img src="`+y+`" alt="image-20230406200537517"></p><p>列含义如下</p><table><thead><tr><th>CONTAINER ID</th><th>NAME</th><th>CPU %</th><th>MEM USAGE/LIMIT</th><th>MEM %</th><th>NET I/O</th><th>BLOCK I/O</th><th>PIDS</th></tr></thead><tbody><tr><td>容器id</td><td>容器名 称</td><td>cpu使用百分比</td><td>使用内存大小/ 最大可用内存</td><td>内存使用 百分比</td><td>网络 IO</td><td>磁盘IO</td><td>容器内线程或 进程的数量</td></tr></tbody></table><p><strong>stats语法</strong></p><blockquote><p>docker stats [OPTIONS] [CONTAINER...]</p><p><strong>OPTIONS</strong> ：可选参数</p><ul><li><code>-a</code> filter: 显示所有容器的资源使用情况，默认只显示正在运行的</li><li><code>--format</code> string：格式化输 出结果</li><li><code>--no-stream</code> : 不间隔刷新，只显示第一次统计结果</li><li><code>--no-trunc</code> : 不截断显示信息，默认 情况下有些字段只显示简略信息，如容器id</li></ul><p><strong>CONTAINER</strong> ：容器</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 监控所有正在运行的容器的资源使用情况</span>
<span class="token function">docker</span> stats
<span class="token comment"># 监控所有容器的资源使用情况，包含未启动的容器</span>
<span class="token function">docker</span> stats <span class="token parameter variable">-a</span>
<span class="token comment"># 只监控centos容器的资源使用情况</span>
<span class="token function">docker</span> stats centos
<span class="token comment"># 监控centos容器的资源使用情况，显示结果不刷新</span>
<span class="token function">docker</span> stats --no-stream centos
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="top-查看容器中运行的进程信息" tabindex="-1"><a class="header-anchor" href="#top-查看容器中运行的进程信息" aria-hidden="true">#</a> top：查看容器中运行的进程信息</h4><p><code>top</code>可以查看容器的进程信息， <code>docker exec CONTAINER ps</code> 也可以查看容器的进程。</p><p>不同的是：</p><ul><li>前者查看的是容器运行在宿主机的进程id。</li><li>后者查看的是容器内的进程id</li></ul><p><strong>top语法</strong></p><blockquote><p>docker top CONTAINER [ps OPTIONS]</p><p><strong>CONTAINER</strong> ：容器</p><p><strong>OPTIONS</strong> ：ps命令的可选参数</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 查看centos镜像的宿主机进程id</span>
<span class="token function">docker</span> <span class="token function">top</span> centos
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="rename-重命名容器" tabindex="-1"><a class="header-anchor" href="#rename-重命名容器" aria-hidden="true">#</a> rename：重命名容器</h4><p><code>rename</code>可以对容器进行重命名，在容器<code>run</code>时如果没有使用<code>--name</code>参数指定容器名称，可以使用 <code>rename</code>进行命名</p><p><strong>rename语法</strong></p><blockquote><p>docker rename CONTAINER NEW_NAME</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 将centos容器重命名为my-centos</span>
<span class="token function">docker</span> <span class="token function">rename</span> centos my-centos
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="attach-连接到容器内" tabindex="-1"><a class="header-anchor" href="#attach-连接到容器内" aria-hidden="true">#</a> attach：连接到容器内</h4><p><code>attach</code>可以连接到容器内，这个容器必须是正在运行的容器，不是运行状态时，会报错</p><p>当使用 <code>ctrl+c</code> 或 <code>exit</code> 等命令退出容器时，会导致容器停止运行。</p><p>所以，不建议在生产环境使用该命令。生产环境可以使用<code>exec</code>命令进入容器</p><p><strong>attach语法</strong></p><blockquote><p>docker attach [OPTIONS] CONTAINER</p><p><strong>OPTIONS</strong> ：可选参数</p><p><code>--sig-proxy=false</code> boolean: 默认<code>true</code>，为<code>false</code>时可以防止容器遇到 <code>ctrl+c</code> 退出信号时停止运行</p><p><strong>CONTAINER</strong> ：容器</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 进入正在运行的centos镜像内</span>
<span class="token function">docker</span> attach centos
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="update-更新一个或多个容器的配置" tabindex="-1"><a class="header-anchor" href="#update-更新一个或多个容器的配置" aria-hidden="true">#</a> update：更新一个或多个容器的配置</h4><p>update可以对容器的配置进行更新</p><p><strong>update语法</strong></p><blockquote><p>docker update [OPTIONS] CONTAINER [CONTAINER...]</p><p><strong>OPTIONS</strong> ：可选参数</p><ul><li><code>-m</code> bytes: 指定容器的内存大小，单位可选b、k、m、g</li><li><code>--memory-swap</code> bytes：</li><li>-<code>-cpu demecial</code>：cpu资源，如1.5表示可以使用宿主机的1.5个cpu资源</li><li>-<code>-cpuset-cpus</code> string：容器 可以使用宿主机的cpu内核编号， 0-3 表示4个内核都可以使用， 1,3 表示只能使用1和3号内 核</li><li><code>--restart</code> string: 指定容器的退出的重启策略。 <ul><li><code>no</code>：不重启；</li><li><code>on-failure</code>：容器非正常退出 时重启；</li><li><code>on-failure:3</code>：非正常退出时重启3次；</li><li><code>alaways</code>：总是重启；</li><li><code>unless-stopped</code>：在容 器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器</li></ul></li><li><code>--pidslimit</code> int: 限制容器进程或线程的数量，默认-1表示不限制</li></ul><p><strong>CONTAINER</strong> ：容器</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 更新centos镜像的内存为2G</span>
<span class="token function">docker</span> update --memory-swap <span class="token parameter variable">-1</span> <span class="token parameter variable">-m</span> 2g centos
<span class="token comment"># 更新容器的重启策略</span>
<span class="token function">docker</span> update <span class="token parameter variable">--restart</span> on-failure:3 centos
<span class="token comment"># 更新tomcat容器的最大线程数为2000</span>
<span class="token function">docker</span> update --pids-limit <span class="token number">2000</span> tomcat
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="logs-查看容器的日志" tabindex="-1"><a class="header-anchor" href="#logs-查看容器的日志" aria-hidden="true">#</a> logs：查看容器的日志</h4><p><strong>logs语法</strong></p><blockquote><p>docker logs [OPTIONS] CONTAINER</p><p><strong>OPTIONS</strong> ：可选参数</p><ul><li><code>-f</code> : 跟踪日志的实时输出</li><li><code>--until</code> string：查看某个时间点之前的日志，格式：2021-06- 03T19:30:20Z。或使用相对时间10m，表示10分钟之前</li><li><code>--since</code> string：查看某个时间点之 后的日志，格式：2021-06-03T19:30:20Z。使用相对时间10m，表示10分钟之内</li><li><code>-n</code> int: 查看 最后几行日志，默认显示全部</li><li><code>-t</code> : 日志中显示时间戳</li></ul><p><strong>CONTAINER</strong> ：容器</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 查看tomcat最后10行日志</span>
<span class="token function">docker</span> logs <span class="token parameter variable">-n</span> <span class="token number">10</span> tomcat
<span class="token comment"># 查看tomcat最后10行日志，并实时监控日志输出</span>
<span class="token function">docker</span> logs <span class="token parameter variable">-n</span> <span class="token number">10</span> <span class="token parameter variable">-f</span> tomcat
<span class="token comment"># 查看最近10分钟的日志</span>
<span class="token function">docker</span> logs <span class="token parameter variable">--since</span> 10m tomcat
<span class="token comment"># 查看6月3号9点到10点之间的日志</span>
<span class="token function">docker</span> logs <span class="token parameter variable">--since</span> <span class="token number">2021</span>-06-03T9:00:00 <span class="token parameter variable">--until</span> <span class="token number">2021</span>-06-03T10:00:00 tomcat
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="wait-阻塞容器-直到容器退出并打印它的退出代码" tabindex="-1"><a class="header-anchor" href="#wait-阻塞容器-直到容器退出并打印它的退出代码" aria-hidden="true">#</a> wait：阻塞容器，直到容器退出并打印它的退出代码</h4><p>wait命令可以阻塞一个或多个容器直到容器退出并打印出他们的退出代码</p><p><strong>wait语法</strong></p><blockquote><p>docker wait CONTAINER [CONTAINER...]</p><p><strong>CONTAINER</strong> ：容器</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 阻塞centos容器，直到它退出并打印退出状态码</span>
<span class="token function">docker</span> <span class="token function">wait</span> centos
<span class="token comment"># 此时新打开一个终端，将centos容器stop掉，切换到wait的终端就可以看到打出一个状态码</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="port-列出端口的映射关系" tabindex="-1"><a class="header-anchor" href="#port-列出端口的映射关系" aria-hidden="true">#</a> port：列出端口的映射关系</h4><p><strong>port语法</strong></p><blockquote><p>docker port CONTAINER [PRIVATE_PORT[/PROTO]]</p><p><strong>CONTAINER</strong> ：容器</p><p><strong>PRIVATE_PORT</strong> ：容器端口</p><p><strong>PROTO</strong> ：端口使用的协议</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 查看my-boot容器的端口映射</span>
<span class="token function">docker</span> port my-boot
<span class="token comment"># 查看my-boot容器的8080端口映射的宿主机端口</span>
<span class="token function">docker</span> port my-boot <span class="token number">8080</span>
<span class="token comment"># 查看my-boot容器使用tcp协议的8080端口映射的宿主机端口</span>
<span class="token function">docker</span> port my-boot <span class="token number">8080</span>/tcp
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="export-将容器打包成一个文件" tabindex="-1"><a class="header-anchor" href="#export-将容器打包成一个文件" aria-hidden="true">#</a> export：将容器打包成一个文件</h4><p><code>export</code>命令可以将容器打包到一个文件中，它和<code>save</code>命令比较容易混淆</p><p><code>export</code>和<code>save</code>的不同之处在于：</p><ul><li><code>save</code>打包的是镜像</li><li><code>export</code>打包的是容器，是容器当时的快照，至于容器的历史记录和元数据信息都会丢失。还有，<code>export</code>的文件在被<code>import</code>成一个镜像时，可以重新指定镜像的名称和版本号</li></ul><p><strong>export语法</strong></p><blockquote><p>docker export [OPTIONS] CONTAINER</p><p><strong>OPTIONS</strong> ：可选参数</p><ul><li><code>-o</code> string: 指定打包文件</li></ul><p><strong>CONTAINER</strong> ：容器</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 将my-boot容器打包到my-boot.tar文件</span>
<span class="token function">docker</span> <span class="token builtin class-name">export</span> <span class="token parameter variable">-o</span> /tmp/my-boot.tar my-boot
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="import-从本地文件或远程文件导入镜像到本地仓库" tabindex="-1"><a class="header-anchor" href="#import-从本地文件或远程文件导入镜像到本地仓库" aria-hidden="true">#</a> import：从本地文件或远程文件导入镜像到本地仓库</h4><p><code>import</code>可以从本地文件或远程文件中导入镜像到本地仓库</p><p>如果是从文件中导入，这个文件需要是<code>export</code>命令导出的文件</p><p><strong>import语法</strong></p><blockquote><p>docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]</p><p><strong>OPTIONS</strong> ：可选参数</p><ul><li><code>-m</code> string: 添加描述信息</li><li><code>-c</code> list: 对创建的容器使用dokerfile指令</li></ul><p><strong>file</strong> ：文件地址</p><p><strong>URL</strong> ：URL地址</p><p><strong>-</strong>：从标准输入终端导入，通常和 linux中的cat命令一起使用</p><p><strong>REPOSITORY</strong> ：本地镜像仓库地址</p><p><strong>TAG</strong> ：镜像版本号</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 从my-boot.tar文件创建镜像</span>
<span class="token function">cat</span> /tmp/my-boot.tar <span class="token operator">|</span> <span class="token function">docker</span> <span class="token function">import</span> -
<span class="token comment"># 从my-boot.tar文件创建镜像</span>
<span class="token function">docker</span> <span class="token function">import</span> /tmp/my-boot.tar
<span class="token comment"># 从my-boot.tar文件创建镜像，并指定镜像名称为my-boot-test、版本号为1.0</span>
<span class="token function">docker</span> <span class="token function">import</span> /tmp/my-boot.tar my-boot-test:1.0
<span class="token comment"># 从my-boot.tar文件创建镜像，备注信息为测试，并指定镜像名称为my-boot-test、版本号为1.0</span>
<span class="token function">docker</span> <span class="token function">import</span> <span class="token parameter variable">--message</span> <span class="token string">&#39;测试&#39;</span> /tmp/my-boot.tar my-boot-test:1.0
<span class="token comment"># 从远程服务器的my-boot.tar文件创建镜像</span>
<span class="token function">docker</span> <span class="token function">import</span> http://192.168.100.1:8080/images/my-boot.tar
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="四、dockerfile自定义镜像" tabindex="-1"><a class="header-anchor" href="#四、dockerfile自定义镜像" aria-hidden="true">#</a> 四、Dockerfile自定义镜像</h2><p>常见的镜像在<code>DockerHub</code>就能找到，但是我们自己写的项目就必须自己构建镜像了。</p><p>而要自定义镜像，就必须先了解镜像的结构才行。</p><h3 id="镜像结构" tabindex="-1"><a class="header-anchor" href="#镜像结构" aria-hidden="true">#</a> 镜像结构</h3><p>镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成。</p><p>我们以<code>MySQL</code>为例，来看看镜像的组成结构</p><p><img src="`+x+'" alt="image.png"></p><p>简单来说，镜像就是在系统函数库、运行环境基础上，添加应用程序文件、配置文件、依赖文件等组合，然后编写好启动脚本打包在一起形成的文件。</p><p>我们要构建镜像，其实就是实现上述打包的过程。</p><h3 id="dockerfile语法" tabindex="-1"><a class="header-anchor" href="#dockerfile语法" aria-hidden="true">#</a> Dockerfile语法</h3><p>我们只需要告诉<code>Docker</code>，我们的镜像的组成，需要哪些<code>BaseImage</code>、需要拷贝什么文件、需要安装什么依赖、启动脚本是什么，将来<code>Docker</code>会帮助我们构建镜像。</p><p><strong>而描述上述信息的文件就是Dockerfile文件。</strong></p><p><strong><code>Dockerfile</code><strong>就是一个文本文件，其中包含一个个的</strong>指令(Instruction)</strong>，用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层<code>Layer</code>。</p><p><img src="'+O+'" alt="image.png"></p>',274),V={href:"https://docs.docker.com/engine/reference/builder",target:"_blank",rel:"noopener noreferrer"},Z=a(`<h3 id="构建java项目" tabindex="-1"><a class="header-anchor" href="#构建java项目" aria-hidden="true">#</a> 构建Java项目</h3><h4 id="基于ubuntu构建java项目" tabindex="-1"><a class="header-anchor" href="#基于ubuntu构建java项目" aria-hidden="true">#</a> 基于Ubuntu构建Java项目</h4><p>需求：基于Ubuntu镜像构建一个新镜像，运行一个java项目</p><ul><li>步骤1：新建一个空文件夹 docker-demo</li><li>步骤2：拷贝Java的 <code>.jar</code>包文件到 docker-demo 这个目录</li><li>步骤3：拷贝jdk的压缩包 jdk8.tar.gz 文件到 docker-demo 这个目录</li><li>步骤4：编写<code>Dockerfile</code>文件到 docker-demo 这个目录</li></ul><p>其中的内容如下：</p><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code><span class="token comment"># 指定基础镜像</span>
<span class="token instruction"><span class="token keyword">FROM</span> ubuntu:16.04</span>
<span class="token comment"># 配置环境变量，JDK的安装目录</span>
<span class="token instruction"><span class="token keyword">ENV</span> JAVA_DIR=/usr/local</span>

<span class="token comment"># 拷贝jdk和java项目的包</span>
<span class="token instruction"><span class="token keyword">COPY</span> ./jdk8.tar.gz <span class="token variable">$JAVA_DIR</span>/</span>
<span class="token instruction"><span class="token keyword">COPY</span> ./docker-demo.jar /tmp/app.jar</span>

<span class="token comment"># 安装JDK</span>
<span class="token instruction"><span class="token keyword">RUN</span> cd <span class="token variable">$JAVA_DIR</span> /</span>
&amp;&amp; tar -xf ./jdk8.tar.gz / #解压
&amp;&amp; mv ./jdk1.8.0_144 ./java8 # 重命名

<span class="token comment"># 配置环境变量</span>
<span class="token instruction"><span class="token keyword">ENV</span> JAVA_HOME=<span class="token variable">$JAVA_DIR</span>/java8</span>
<span class="token instruction"><span class="token keyword">ENV</span> PATH=<span class="token variable">$PATH</span>:<span class="token variable">$JAVA_HOME</span>/bin</span>

<span class="token comment"># 暴露端口</span>
<span class="token instruction"><span class="token keyword">EXPOSE</span> 8090</span>
<span class="token comment"># 入口，java项目的启动命令</span>
<span class="token instruction"><span class="token keyword">ENTRYPOINT</span> java -jar /tmp/app.jar</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>步骤5：进入 docker-demo 目录</li><li>步骤6：运行命令：</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># . 表示 dockerfile 所在的目录 javaweb:1.0 构建完成的镜像名称</span>
<span class="token function">docker</span> build <span class="token parameter variable">-t</span> javaweb:1.0 <span class="token builtin class-name">.</span>

<span class="token function">docker</span> images

<span class="token comment"># 启动镜像</span>
<span class="token function">docker</span> run <span class="token parameter variable">--name</span> web <span class="token parameter variable">-p</span> <span class="token number">8090</span>:8090 <span class="token parameter variable">-d</span> javaweb:1.0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,8),J={href:"http://192.168.150.101:8090/hello/count",target:"_blank",rel:"noopener noreferrer"},H=a(`<h4 id="基于java8构建java项目" tabindex="-1"><a class="header-anchor" href="#基于java8构建java项目" aria-hidden="true">#</a> 基于Java8构建Java项目</h4><p>大多数情况下，我们都可以在一些安装了部分软件的基础镜像上做改造。</p><p>例如，构建java项目的镜像，可以在已经准备了<code>JDK</code>的基础镜像基础上构建。</p><p>需求：基于java:8-alpine镜像，将一个Java项目构建为镜像</p><p>实现思路如下：</p><ul><li>① 新建一个空的目录，然后在目录中新建一个文件，命名为 Dockerfile</li><li>② 拷贝<code>.jar</code>到这个目录中</li><li>③ 编写Dockerfile文件： <ul><li>a ）基于java:8-alpine作为基础镜像</li><li>b ）将<code>app.jar</code>拷贝到镜像中</li><li>c ）暴露端口</li><li>d ）编写入口<code>ENTRYPOINT</code></li></ul></li></ul><p>内容如下：</p><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code><span class="token instruction"><span class="token keyword">FROM</span> java:8-alpine</span>
<span class="token instruction"><span class="token keyword">COPY</span> ./app.jar /tmp/app.jar</span>
<span class="token instruction"><span class="token keyword">EXPOSE</span> 8090</span>
<span class="token instruction"><span class="token keyword">ENTRYPOINT</span> java -jar /tmp/app.jar</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>④ 使用docker build命令构建镜像</li></ul><div class="language-docker line-numbers-mode" data-ext="docker"><pre class="language-docker"><code>docker build -t javaweb:2.0 .
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>⑤ 使用docker run创建容器并运行</li></ul><p>小结：</p><ol><li>Dockerfile的本质是一个文件，通过指令描述镜像的构建过程</li><li>Dockerfile的第一行必须是FROM，从一个基础镜像来构建</li><li>基础镜像可以是基本操作系统，如Ubuntu。也可以是其他人制作好的镜像，例如：java:8-alpine</li></ol><h2 id="五、docker-compose" tabindex="-1"><a class="header-anchor" href="#五、docker-compose" aria-hidden="true">#</a> 五、Docker-Compose</h2><p>Docker Compose可以基于Compose文件帮我们快速的部署分布式应用，而无需手动一个个创建和运行容器！</p><h3 id="初识dockercompose" tabindex="-1"><a class="header-anchor" href="#初识dockercompose" aria-hidden="true">#</a> 初识DockerCompose</h3><p>Compose文件是一个文本文件，通过指令定义集群中的每个容器如何运行。</p><p>将 <code>docker run</code> 中的所有参数转换为 <code>Compose</code> 形式</p><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code>version<span class="token operator">:</span> <span class="token string">&quot;3.8&quot;</span>

services<span class="token operator">:</span>
	mysql<span class="token operator">:</span> <span class="token comment">// 对应 --name</span>
		image<span class="token operator">:</span> mysql<span class="token operator">:</span><span class="token number">5.7</span>.<span class="token number">25</span> <span class="token comment">// 对应镜像名称</span>
		environment<span class="token operator">:</span> <span class="token comment">// 对应 -e</span>
			MYSQL_ROOT_PASSWORD<span class="token operator">:</span> <span class="token number">123</span> 
		volumes<span class="token operator">:</span> <span class="token comment">// 对应 -v</span>
			- <span class="token string">&quot;/tmp/mysql/data:/var/lib/mysql&quot;</span>
			- <span class="token string">&quot;/tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf&quot;</span>
	web<span class="token operator">:</span>
		build<span class="token operator">:</span> .
		ports<span class="token operator">:</span>
			- <span class="token string">&quot;8090:8090&quot;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应👇👇👇</p><p><img src="`+I+'" alt="image.png"></p><p>上面的Compose文件就描述一个项目，其中包含两个容器：</p><ul><li>mysql：一个基于mysql:5.7.25镜像构建的容器，并且挂载了两个目录</li><li>web：一个基于docker build临时构建的镜像容器，映射端口时8090</li></ul>',23),z={href:"https://docs.docker.com/compose/compose-file/",target:"_blank",rel:"noopener noreferrer"},Q=a('<blockquote><p>其实DockerCompose文件可以看做是将多个<code>docker run</code>命令写到一个文件，只是语法稍有差异。</p></blockquote><h3 id="部署微服务集群" tabindex="-1"><a class="header-anchor" href="#部署微服务集群" aria-hidden="true">#</a> 部署微服务集群</h3><p><strong>实现思路</strong>：</p><p>①编写<code>compose</code>文件</p><p>②修改自己的微服务项目，将数据库、<code>nacos</code>地址都命名为<code>docker-compose</code>中的服务名</p><p>③使用maven打包工具，将项目中的每个微服务都打包为 <code>.jar</code></p><p>④将打包好的<code>.jar</code>拷贝到自己微服务项目中的每一个对应的子目录中</p><p>⑤将自己的微服务项目上传至虚拟机，利用 <code>docker-compose up -d</code> 来部署</p><h4 id="compose文件" tabindex="-1"><a class="header-anchor" href="#compose文件" aria-hidden="true">#</a> compose文件</h4><p>假设现在有如下几个服务需要部署</p><p><img src="'+q+`" alt="image.png"></p><p>内容如下：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">&quot;3.2&quot;</span>

<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">nacos</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> nacos/nacos<span class="token punctuation">-</span>server
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
      <span class="token key atrule">MODE</span><span class="token punctuation">:</span> standalone
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">&quot;8848:8848&quot;</span>
  <span class="token key atrule">mysql</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> mysql<span class="token punctuation">:</span>5.7.25
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
      <span class="token key atrule">MYSQL_ROOT_PASSWORD</span><span class="token punctuation">:</span> <span class="token number">123</span>
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">&quot;$PWD/mysql/data:/var/lib/mysql&quot;</span>
      <span class="token punctuation">-</span> <span class="token string">&quot;$PWD/mysql/conf:/etc/mysql/conf.d/&quot;</span>
  <span class="token key atrule">userservice</span><span class="token punctuation">:</span>
    <span class="token key atrule">build</span><span class="token punctuation">:</span> ./user<span class="token punctuation">-</span>service
  <span class="token key atrule">orderservice</span><span class="token punctuation">:</span>
    <span class="token key atrule">build</span><span class="token punctuation">:</span> ./order<span class="token punctuation">-</span>service
  <span class="token key atrule">gateway</span><span class="token punctuation">:</span>
    <span class="token key atrule">build</span><span class="token punctuation">:</span> ./gateway
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">&quot;10010:10010&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，其中包含5个service服务：</p><ul><li>nacos：作为注册中心和配置中心 <ul><li>image: nacos/nacos-server： 基于nacos/nacos-server镜像构建</li><li>environment：环境变量 <ul><li>MODE: standalone：单点模式启动</li></ul></li><li>ports：端口映射，这里暴露了8848端口</li></ul></li><li>mysql：数据库 <ul><li>image: mysql:5.7.25：镜像版本是mysql:5.7.25</li><li>environment：环境变量 <ul><li>MYSQL_ROOT_PASSWORD: 123：设置数据库root账户的密码为123</li></ul></li><li>volumes：数据卷挂载，这里挂载了mysql的data、conf目录，其中有我提前准备好的数据</li></ul></li><li>userservice、orderservice、gateway：都是基于Dockerfile临时构建的</li></ul><h4 id="修改微服务配置" tabindex="-1"><a class="header-anchor" href="#修改微服务配置" aria-hidden="true">#</a> 修改微服务配置</h4><p>因为微服务将来要部署为<code>docker</code>容器，而容器之间互联不是通过<code>IP</code>地址，而是通过容器名。这里我们将order-service、user-service、gateway服务的mysql、nacos地址都修改为基于容器名的访问。如下所示：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">datasource</span><span class="token punctuation">:</span>
    <span class="token key atrule">url</span><span class="token punctuation">:</span> jdbc<span class="token punctuation">:</span>mysql<span class="token punctuation">:</span>//mysql<span class="token punctuation">:</span>3306/cloud_order<span class="token punctuation">?</span>useSSL=false
    <span class="token key atrule">username</span><span class="token punctuation">:</span> root
    <span class="token key atrule">password</span><span class="token punctuation">:</span> <span class="token number">123</span>
    <span class="token key atrule">driver-class-name</span><span class="token punctuation">:</span> com.mysql.jdbc.Driver
  <span class="token key atrule">application</span><span class="token punctuation">:</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> orderservice
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>
      <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> nacos<span class="token punctuation">:</span><span class="token number">8848</span> <span class="token comment"># nacos服务地址</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="打包" tabindex="-1"><a class="header-anchor" href="#打包" aria-hidden="true">#</a> 打包</h4><p>接下来需要将我们的每个微服务都打包。因为之前查看到<code>Dockerfile</code>中的<code>jar</code>包名称都是<code>app.jar</code>，因此我们的每个微服务都需要用这个名称。</p><p>可以通过修改<code>pom.xml</code>中的打包名称来实现，每个微服务都需要修改</p><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">&gt;</span></span>
  <span class="token comment">&lt;!-- 服务打包的最终名称 --&gt;</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>finalName</span><span class="token punctuation">&gt;</span></span>app<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>finalName</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>打包后：</p><p><img src="`+T+'" alt="image.png"></p><h4 id="拷贝jar包到部署目录" tabindex="-1"><a class="header-anchor" href="#拷贝jar包到部署目录" aria-hidden="true">#</a> 拷贝jar包到部署目录</h4><p>编译打包好的<code>app.jar</code>文件，需要放到<code>Dockerfile</code>的同级目录中。</p><blockquote><p>注意：每个微服务的<code>app.jar</code>放到与服务名称对应的目录，别搞错了</p></blockquote><p><img src="'+E+'" alt="image.png"></p><h4 id="部署" tabindex="-1"><a class="header-anchor" href="#部署" aria-hidden="true">#</a> 部署</h4><p>最后，我们需要将整个项目文件夹上传到虚拟机中，利用<code>DockerCompose</code>部署。</p><p>上传到任意目录：</p><p><img src="'+R+`" alt="image.png"></p><p>部署：</p><p>进入项目目录，然后运行下面的命令：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker-compose</span> up <span class="token parameter variable">-d</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="六、docker镜像仓库" tabindex="-1"><a class="header-anchor" href="#六、docker镜像仓库" aria-hidden="true">#</a> 六、Docker镜像仓库</h2><p>搭建镜像仓库可以基于<code>Docker</code>官方提供的<code>DockerRegistry</code>来实现。</p>`,37),$={href:"https://hub.docker.com/_/registry",target:"_blank",rel:"noopener noreferrer"},ss=a(`<h3 id="搭建私有镜像仓库" tabindex="-1"><a class="header-anchor" href="#搭建私有镜像仓库" aria-hidden="true">#</a> 搭建私有镜像仓库</h3><h4 id="简化版镜像仓库" tabindex="-1"><a class="header-anchor" href="#简化版镜像仓库" aria-hidden="true">#</a> 简化版镜像仓库</h4><p><code>Docker</code>官方的<code>Docker Registry</code>是一个基础版本的<code>Docker</code>镜像仓库，具备仓库管理的完整功能，但是没有图形化界面。</p><p>搭建方式比较简单，命令如下</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token punctuation">\\</span>
    <span class="token parameter variable">--restart</span><span class="token operator">=</span>always <span class="token punctuation">\\</span>
    <span class="token parameter variable">--name</span> registry	<span class="token punctuation">\\</span>
    <span class="token parameter variable">-p</span> <span class="token number">5000</span>:5000 <span class="token punctuation">\\</span>
    <span class="token parameter variable">-v</span> registry-data:/var/lib/registry <span class="token punctuation">\\</span>
    registry
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>命令中挂载了一个数据卷<code>registry-data</code>到容器内的<code>/var/lib/registry</code> 目录，这是私有镜像库存放数据的目录。</p>`,6),ns={href:"http://YourIp:5000/v2/_catalog",target:"_blank",rel:"noopener noreferrer"},as=a(`<h4 id="带有图形化界面版本" tabindex="-1"><a class="header-anchor" href="#带有图形化界面版本" aria-hidden="true">#</a> 带有图形化界面版本</h4><p>使用<code>DockerCompose</code>部署带有图象界面的<code>DockerRegistry</code></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>version: <span class="token string">&#39;3.0&#39;</span>
services:
  registry:
    image: registry
    volumes:
      - ./registry-data:/var/lib/registry
  ui:
    image: joxit/docker-registry-ui:static
    ports:
      - <span class="token number">8080</span>:80
    environment:
      - <span class="token assign-left variable">REGISTRY_TITLE</span><span class="token operator">=</span>我的私有仓库
      - <span class="token assign-left variable">REGISTRY_URL</span><span class="token operator">=</span>http://registry:5000
    depends_on:
      - registry
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="配置docker信任地址" tabindex="-1"><a class="header-anchor" href="#配置docker信任地址" aria-hidden="true">#</a> 配置Docker信任地址</h4><p>我们的私服采用的是<code>http</code>协议，默认不被<code>Docker</code>信任，所以需要做一个配置：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 打开要修改的文件</span>
<span class="token function">vi</span> /etc/docker/daemon.json
<span class="token comment"># 添加内容：</span>
<span class="token string">&quot;insecure-registries&quot;</span>:<span class="token punctuation">[</span><span class="token string">&quot;http://192.168.150.101:8080&quot;</span><span class="token punctuation">]</span>
<span class="token comment"># 重加载</span>
systemctl daemon-reload
<span class="token comment"># 重启docker</span>
systemctl restart <span class="token function">docker</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="推送、拉取镜像" tabindex="-1"><a class="header-anchor" href="#推送、拉取镜像" aria-hidden="true">#</a> 推送、拉取镜像</h4><p>推送镜像到私有镜像服务必须先<code>tag</code></p><p>① 重新<code>tag</code>本地镜像，名称前缀为私有仓库的地址：192.168.150.101:8080/</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> tag nginx:latest <span class="token number">192.168</span>.150.101:8080/nginx:1.0 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>② 推送镜像</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> push <span class="token number">192.168</span>.150.101:8080/nginx:1.0 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>③ 拉取镜像</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> pull <span class="token number">192.168</span>.150.101:8080/nginx:1.0 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="七、docker-desktop" tabindex="-1"><a class="header-anchor" href="#七、docker-desktop" aria-hidden="true">#</a> 七、Docker desktop</h2><h3 id="下载-1" tabindex="-1"><a class="header-anchor" href="#下载-1" aria-hidden="true">#</a> 下载</h3>`,16),es={href:"https://www.docker.com/",target:"_blank",rel:"noopener noreferrer"},ts=a('<p><img src="'+S+'" alt="image-20230530105938295"></p><h3 id="启动-docker-desktop" tabindex="-1"><a class="header-anchor" href="#启动-docker-desktop" aria-hidden="true">#</a> 启动 Docker desktop</h3><p>双击启动</p><ul><li>若提示 <code>virtual</code> 虚拟化之类的错误（关键字 virtual ），需要进入<code>bios</code>设置，开启虚拟化</li><li>若提示 <code>WSL</code> 之类的错误（关键字 WSL），需要在命令行执行 <code>wsl --update</code></li></ul><p><img src="'+C+'" alt="image-20230530113300656"></p><p>Docker desktop 它内置了 <code>docker</code> 命令。</p><p>把它安装到系统之后，可以在命令行看下 <code>docker</code> 命令是否可用：</p><blockquote><p>有提示，说明可用</p></blockquote><p><img src="'+D+'" alt="image-20230530110009093"></p><h3 id="使用" tabindex="-1"><a class="header-anchor" href="#使用" aria-hidden="true">#</a> 使用</h3><p>我们来看看 <code>docker desktop</code> 的界面：</p><ul><li><code>images</code> 是本地的所有镜像</li><li><code>containers</code> 是镜像跑起来的容器</li></ul><p><img src="'+P+'" alt="image-20230530134726571"></p><p><img src="'+w+'" alt="image-20230530134823163"></p><p>我们 <code>pull</code> 一个镜像试试</p><p>搜索 <code>nginx</code> 镜像，点击 <code>pull</code>（搜索这步需要科学上网，不然搜不到）。</p><p><code>pull</code> 下来之后，就可以在本地 <code>images</code> 看到了：</p><p><img src="'+M+'" alt="image-20230530134926690"></p><p>点击 <code>run</code> 会让你填一些参数：</p><ul><li>首先是名字，如果不填，<code>docker desktop</code> 会给你生成随机的容器名字。</li><li>然后是端口，容器内跑的 <code>nginx</code> 服务是在 <code>80</code> 端口，你要把宿主机的某个端口映射到容器的 <code>80</code> 端口才可以访问。</li><li>接下来是数据卷 <code>volume</code>，这个是把宿主机某个目录挂到容器内。</li><li>最后是环境变量。</li></ul><p><img src="'+L+'" alt="image-20230530135050542"></p><p>挂载本地的 <code>D:/zlw-test/aaa</code> 到容器内的 <code>/usr/share/nginx/html</code> 目录。</p><p>点击 <code>run</code>：</p><p><img src="'+F+'" alt="image-20230530135533040"></p><p>可以看到容器内的 <code>nginx</code> 服务跑起来了。</p><p>我们在 <code>D:/zlw-test/aaa</code> 目录下添加一个 <code>index.html</code>:</p><p><img src="'+j+'" alt="image-20230530135615602"></p><p>浏览器访问 http://localhost 就可以访问到：</p><p><img src="'+X+'" alt="image-20230530135641225"></p><p>这就说明数据卷挂载成功了。</p><p>点击 <code>files</code> 标签就可以看到容器内的文件。</p><p>可以看到 <code>/usr/share/nginx/html</code> 被标识为 <code>mounted</code>，就是挂载目录的意思：</p><p><img src="'+G+'" alt="image-20230530135801100"></p><p>挂载到的目录，在镜像搜索结果页有写：</p><p><img src="'+K+'" alt="image-20230530144047358"></p><p>通过命令行 <code>docker run</code> 来跑镜像， <code>-v</code> 是指定挂载的数据卷，后面的 <code>:ro</code> 代表 <code>readonly</code>，也就是容器内这个目录只读，<code>:rw</code> 表示容器内可以读写这个目录。</p><p>这就是数据卷的作用。</p><p>此外，你还可以进入到容器内执行各种命令：</p><p><img src="'+_+'" alt="image-20230530144156926"></p><p>其它的相信熟悉<code>Docker</code>的朋友，一看就知道是干什么的了，这里就不一 一说明了</p>',40);function os(is,cs){const e=i("ExternalLinkIcon");return c(),l("div",null,[U,n("p",null,[s("参考阿里云的镜像加速文档："),n("a",W,[s("https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors"),t(e)])]),B,n("p",null,[s("更新详细语法说明，请参考官网文档： "),n("a",V,[s("https://docs.docker.com/engine/reference/builder"),t(e)])]),Z,n("p",null,[s("最后访问 "),n("a",J,[s("http://192.168.150.101:8090/hello/count"),t(e)]),s("，其中的ip改成你的虚拟机ip")]),H,n("blockquote",null,[n("p",null,[s("DockerCompose的详细语法参考官网："),n("a",z,[s("https://docs.docker.com/compose/compose-file/"),t(e)])])]),Q,n("p",null,[s("官网地址："),n("a",$,[s("https://hub.docker.com/_/registry"),t(e)])]),ss,n("p",null,[s("访问"),n("a",ns,[s("http://YourIp:5000/v2/_catalog"),t(e)]),s(" 可以查看当前私有镜像服务中包含的镜像")]),as,n("p",null,[s("下载地址："),n("a",es,[s("https://www.docker.com/"),t(e)])]),ts])}const rs=o(Y,[["render",os],["__file","Docker.html.vue"]]);export{rs as default};
