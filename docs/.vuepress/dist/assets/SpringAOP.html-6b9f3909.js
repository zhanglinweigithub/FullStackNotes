import{_ as c,M as o,p,q as l,R as n,N as e,V as t,t as s,a1 as i}from"./framework-5866ffd3.js";const u={},d=n("h1",{id:"目录",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#目录","aria-hidden":"true"},"#"),s(" 目录")],-1),r={class:"table-of-contents"},k=i(`<h2 id="spring-aop" tabindex="-1"><a class="header-anchor" href="#spring-aop" aria-hidden="true">#</a> Spring AOP</h2><p><code>AOP</code>（Aspect-Oriented Programming，面向切面编程）能够将那些与业务无关，却为业务模块所共同调用的逻辑 或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度</p><blockquote><p>大白话说就是：在不改变源代码的情况下，实现对源代码功能的增强</p></blockquote><p><code>Spring AOP</code>是基于动态代理的</p><ul><li>如果要代理的对象实现了某个接口，那么就会使用<code>JDK</code>动态代理去创建代理对象；</li><li>而对于没有实现接口的对象，就使用<code>CGlib</code>动态代理生成一个被代理对象的子类来作为代理。</li></ul><p><code>Spring AOP</code>中已经集成了<code>AspectJ</code></p><ul><li><code>Spring AOP</code> 是属于运行时增强，而<code>AspectJ</code>是编译时增强。</li><li><code>Spring AOP</code>基于代理（Proxying），而<code>AspectJ</code>基于字节码操作（Bytecode Manipulation）。</li></ul><h2 id="jdk动态代理、cglib动态代理" tabindex="-1"><a class="header-anchor" href="#jdk动态代理、cglib动态代理" aria-hidden="true">#</a> JDK动态代理、CGLIB动态代理</h2><h3 id="jdk动态代理" tabindex="-1"><a class="header-anchor" href="#jdk动态代理" aria-hidden="true">#</a> JDK动态代理</h3><p><code>jdk</code>中是使用<code>Proxy</code>类来创建代理的，而<code>Proxy</code>类只能为接口生成代理类 ，所以<code>jdk</code>动态代理只能为接口生成代理 <code>jdk</code>中为实现代理提供了支持，主要用到2个类：</p><blockquote><p>java.lang.reflect.Proxy java.lang.reflect.InvocationHandler</p></blockquote><p><strong>java.lang.reflect.Proxy</strong></p><p>这是<code>jdk</code>动态代理中主要的一个类，里面有一些静态方法会经常用到</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 为指定的接口创建代理类，返回代理类的Class对象 </span>
<span class="token comment">// loader：定义代理类的类加载器</span>
<span class="token comment">// interfaces：指定需要实现的接口列表，创建的代理默认会按顺序实现interfaces指定的接口</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">getProxyClass</span><span class="token punctuation">(</span><span class="token class-name">ClassLoader</span> loader<span class="token punctuation">,</span>
										<span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> interfaces<span class="token punctuation">)</span>
<span class="token comment">// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - </span>

<span class="token comment">// 创建代理类的实例对象</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Object</span> <span class="token function">newProxyInstance</span><span class="token punctuation">(</span><span class="token class-name">ClassLoader</span> loader<span class="token punctuation">,</span>
					<span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> interfaces<span class="token punctuation">,</span><span class="token class-name">InvocationHandler</span> h<span class="token punctuation">)</span>
<span class="token comment">// 其中 InvocationHandler是个接口</span>
<span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Object</span> proxy<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span><span class="token punctuation">;</span>
<span class="token doc-comment comment">/** 
newProxyInstance方法会返回一个代理对象，当调用代理对象的任何方法的时候，
就会被 InvocationHandler 接口的 invoke 方法处理，
所以主要代码需要卸载 invoke 方法中
*/</span>
<span class="token comment">// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - </span>

<span class="token comment">// 判断指定的类是否是一个代理类</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isProxyClass</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> cl<span class="token punctuation">)</span>
<span class="token comment">// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - </span>

<span class="token comment">// 获取代理对象的 InvocationHandler 对象</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">InvocationHandler</span> <span class="token function">getInvocationHandler</span><span class="token punctuation">(</span><span class="token class-name">Object</span> proxy<span class="token punctuation">)</span>
											<span class="token keyword">throws</span> <span class="token class-name">IllegalArgumentException</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="创建代理" tabindex="-1"><a class="header-anchor" href="#创建代理" aria-hidden="true">#</a> 创建代理</h4><h5 id="方式一" tabindex="-1"><a class="header-anchor" href="#方式一" aria-hidden="true">#</a> 方式一</h5><blockquote><p>1.使用<code>InvocationHandler</code>接口创建代理类的处理器 2.使用<code>Proxy</code>类的静态方法<code>newProxyInstance</code>直接创建代理对象 3.使用代理对象 （也可以自定义一个类，实现 <code>InvocationHandler</code> 接口，重写 <code>invoke</code> 方法来作为代理类的处理器）</p></blockquote><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// IService 接口</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IService</span> <span class="token punctuation">{</span>
	<span class="token keyword">void</span> <span class="token function">m1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token function">m2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token function">m3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">m2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
	<span class="token comment">// 1. 创建代理类的处理器</span>
	<span class="token class-name">InvocationHandler</span> invocationHandler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InvocationHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token annotation punctuation">@Override</span>
		<span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Object</span> proxy<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>
			<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;我是InvocationHandler，被调用的方法是：&quot;</span> <span class="token operator">+</span>
			method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token comment">// 2. 创建代理实例</span>
	<span class="token class-name">IService</span> proxyService <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">IService</span><span class="token punctuation">)</span> <span class="token class-name">Proxy</span><span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span><span class="token class-name">IService</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> 
                                                              <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token class-name">IService</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">,</span> invocationHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 3. 调用代理的方法</span>
	proxyService<span class="token punctuation">.</span><span class="token function">m1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	proxyService<span class="token punctuation">.</span><span class="token function">m2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	proxyService<span class="token punctuation">.</span><span class="token function">m3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="方式二" tabindex="-1"><a class="header-anchor" href="#方式二" aria-hidden="true">#</a> 方式二</h5><blockquote><p>1.调用Proxy.getProxyClass方法获取代理类的<code>Class</code>对象 2.使用<code>InvocationHandler</code>接口创建代理类的处理器 3.通过代理类和<code>InvocationHandler</code>创建代理对象 4.上面已经创建好代理对象了，接着我们就可以使用代理对象了</p></blockquote><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 创建 IService 接口的代理对象</span>
<span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">m1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
	<span class="token comment">// 1. 获取接口对应的代理类</span>
	<span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">IService</span><span class="token punctuation">&gt;</span></span> proxyClass <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">IService</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>
		<span class="token class-name">Proxy</span><span class="token punctuation">.</span><span class="token function">getProxyClass</span><span class="token punctuation">(</span><span class="token class-name">IService</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> 
                            <span class="token class-name">IService</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 2. 创建代理类的处理器</span>
	<span class="token class-name">InvocationHandler</span> invocationHandler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InvocationHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token annotation punctuation">@Override</span>
		<span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Object</span> proxy<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>
			<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;我是InvocationHandler，被调用的方法是：&quot;</span> <span class="token operator">+</span> method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token comment">// 3. 创建代理实例</span>
	<span class="token class-name">IService</span> proxyService <span class="token operator">=</span> proxyClass<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span><span class="token class-name">InvocationHandler</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
        							  <span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>invocationHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 4. 调用代理的方法</span>
	proxyService<span class="token punctuation">.</span><span class="token function">m1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	proxyService<span class="token punctuation">.</span><span class="token function">m2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	proxyService<span class="token punctuation">.</span><span class="token function">m3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="cglib动态代理" tabindex="-1"><a class="header-anchor" href="#cglib动态代理" aria-hidden="true">#</a> CGLIB动态代理</h3><p>如果我们想为普通的类也实现代理功能，我们就需要用到<code>cglib</code>来实现</p><p><code>cglib</code>是一个强大、高性能的字节码生成库，它用于在运行时扩展<code>Java</code>类和实现接口；</p><p>本质上它是通过动态的生成一个子类去覆盖所要代理的类（非final修饰的类和方法）。</p><p><code>Enhancer</code>可能是<code>CGLIB</code>中最常用的 一个类，和<code>jdk</code>中的<code>Proxy</code>不同的是，<code>Enhancer</code>既能够代理普通的<code>class</code>，也能够代理接口。</p><p><code>Enhancer</code>创 建一个被代理对象的子类并且拦截所有的方法调用（包括从<code>Object</code>中继承的<code>toString</code>和<code>hashCode</code>方 法）。</p><p><code>Enhancer</code>不能够拦截<code>final</code>方法，例如<code>Object.getClass()</code>方法，这是由于<code>Java</code> <code>final</code>方法语义决定 的。</p><p>基于同样的道理，<code>Enhancer</code>也不能对<code>final</code>类进行代理操作</p><h2 id="关注点、横切关注点、连接点、切入点" tabindex="-1"><a class="header-anchor" href="#关注点、横切关注点、连接点、切入点" aria-hidden="true">#</a> 关注点、横切关注点、连接点、切入点</h2><ul><li>关注点是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能</li><li>横切关注点也是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。</li><li>连接点代表一个应用程序的某个位置，在这个位置我们可以插入一个<code>AOP</code>切面，它实际上是个应用程序执行<code>Spring AOP</code>的位置</li><li>切入点是一个或一组连接点，通知将在这些位置执行</li></ul><h2 id="通知" tabindex="-1"><a class="header-anchor" href="#通知" aria-hidden="true">#</a> 通知</h2><p>通知是个在方法执行前或执行后要做的动作，实际上是程序执行时要通过<code>SpringAOP</code>框架触发的代码段</p><p><code>Spring</code>切面可以应用五种类型的通知：</p><ul><li><strong>before</strong>：前置通知，在一个方法执行前被调用。</li><li><strong>after</strong>: 在方法执行之后调用的通知，无论方法执行是否成功。</li><li><strong>after-returning</strong>: 仅当方法成功完成后执行的通知。</li><li><strong>after-throwing</strong>: 在方法抛出异常退出时执行的通知。</li><li><strong>around</strong>: 在方法执行之前和之后调用的通知。</li></ul><h2 id="springaop中一些概念" tabindex="-1"><a class="header-anchor" href="#springaop中一些概念" aria-hidden="true">#</a> SpringAOP中一些概念</h2><p><strong>目标对象(target)</strong> 目标对象指将要被增强的对象，即包含主业务逻辑的类对象。</p><p><strong>连接点(JoinPoint)</strong> 连接点，程序运行的某一个点，比如执行某个方法，在<code>Spring AOP</code>中<code>Join Point</code>总是表示一个方法的执行</p><p><strong>代理对象(Proxy)</strong><code>AOP</code>中会通过代理的方式，对目标对象生成一个代理对象，代理对象中会加入需要增强功能，通过代理 对象来间接的方式目标对象，起到增强目标对象的效果。</p><p><strong>通知(Advice)</strong> 需要在目标对象中增强的功能，如：业务方法前验证用户的功能、方法执行之后打印方法的执行日志。 通知中有2个重要的信息：方法的什么地方，执行什么操作，这2个信息通过通知来指定。</p><p><strong>切入点(Pointcut )</strong> 用来指定需要将通知使用到哪些地方，比如需要用在哪些类的哪些方法上，切入点就是做这个配置的。</p><p><strong>切面（Aspect）</strong> 通知（Advice）和切入点（Pointcut）的组合。切面来定义在哪些地方（Pointcut）执行什么操作 （Advice）。</p><p><strong>顾问（Advisor)</strong><code>Advisor</code> 其实它就是 <code>Pointcut</code> 与 <code>Advice</code> 的组合，<code>Advice</code> 是要增强的逻辑，而增强的逻辑要在什么地方 执行是通过<code>Pointcut</code>来指定的，所以 <code>Advice</code> 必需与 <code>Pointcut</code> 组合在一起，这就诞生了 <code>Advisor</code> 这个 类，<code>spring Aop</code>中提供了一个<code>Advisor</code>接口将<code>Pointcut</code> 与 <code>Advice</code> 的组合起来。 <code>Advisor</code>有好几个称呼：顾问、通知器。</p>`,43);function v(m,b){const a=o("router-link");return p(),l("div",null,[d,n("nav",r,[n("ul",null,[n("li",null,[e(a,{to:"#spring-aop"},{default:t(()=>[s("Spring AOP")]),_:1})]),n("li",null,[e(a,{to:"#jdk动态代理、cglib动态代理"},{default:t(()=>[s("JDK动态代理、CGLIB动态代理")]),_:1}),n("ul",null,[n("li",null,[e(a,{to:"#jdk动态代理"},{default:t(()=>[s("JDK动态代理")]),_:1})]),n("li",null,[e(a,{to:"#cglib动态代理"},{default:t(()=>[s("CGLIB动态代理")]),_:1})])])]),n("li",null,[e(a,{to:"#关注点、横切关注点、连接点、切入点"},{default:t(()=>[s("关注点、横切关注点、连接点、切入点")]),_:1})]),n("li",null,[e(a,{to:"#通知"},{default:t(()=>[s("通知")]),_:1})]),n("li",null,[e(a,{to:"#springaop中一些概念"},{default:t(()=>[s("SpringAOP中一些概念")]),_:1})])])]),k])}const h=c(u,[["render",v],["__file","SpringAOP.html.vue"]]);export{h as default};
