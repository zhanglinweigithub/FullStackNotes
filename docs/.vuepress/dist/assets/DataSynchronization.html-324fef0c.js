import{_ as s,M as l,p as t,q as r,R as e,N as d,V as a,t as o,a1 as i}from"./framework-5866ffd3.js";const p="/FullStackNotes/assets/image-20210725152222497-d2223f19.png",n="/FullStackNotes/assets/image-20210725152700914-0d6d2065.png",m="/FullStackNotes/assets/image-20210725153201086-ba535b71.png",f="/FullStackNotes/assets/image-20210725153359022-435875fd.png",g="/FullStackNotes/assets/image-20210725153524190-b370fb4c.png",_="/FullStackNotes/assets/image-20210725153715910-6e3ac8b0.png",u="/FullStackNotes/assets/image-20210725153937031-15526cc6.png",h="/FullStackNotes/assets/image-20210725154155984-9ebea34f.png",v="/FullStackNotes/assets/image-20210725154216392-9b347241.png",b="/FullStackNotes/assets/image-20210725154405899-841f6635.png",k={},N=e("h1",{id:"目录",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#目录","aria-hidden":"true"},"#"),o(" 目录")],-1),R={class:"table-of-contents"},S=i('<h2 id="主从数据同步原理" tabindex="-1"><a class="header-anchor" href="#主从数据同步原理" aria-hidden="true">#</a> 主从数据同步原理</h2><h3 id="全量同步" tabindex="-1"><a class="header-anchor" href="#全量同步" aria-hidden="true">#</a> 全量同步</h3><p>主从第一次建立连接时，会执行<strong>全量同步</strong>，将<code>master</code>节点的所有数据都拷贝给<code>slave</code>节点，流程：</p><p><img src="'+p+'" alt="image-20210725152222497"></p><p>这里有一个问题，<code>master</code>如何得知<code>salve</code>是第一次来连接呢？？</p><p>有几个概念，可以作为判断依据：</p><ul><li><strong>Replication Id</strong>：简称<code>replid</code>，是数据集的标记，<code>id</code>一致则说明是同一数据集。每一个<code>master</code>都有唯一的<code>replid</code>，<code>slave</code>则会继承<code>master</code>节点的<code>replid</code></li><li><strong>offset</strong>：偏移量，随着记录在<code>repl_baklog</code>中的数据增多而逐渐增大。<code>slave</code>完成同步时也会记录当前同步的<code>offset</code>。如果<code>slave</code>的<code>offset</code>小于<code>master</code>的<code>offset</code>，说明<code>slave</code>数据落后于<code>master</code>，需要更新。</li></ul><p>因此<code>slave</code>做数据同步，必须向<code>master</code>声明自己的<code>replication id</code> 和<code>offset</code>，<code>master</code>才可以判断到底需要同步哪些数据。</p><p>因为<code>slave</code>原本也是一个<code>master</code>，有自己的<code>replid</code>和<code>offset</code>，当第一次变成<code>slave</code>，与<code>master</code>建立连接时，发送的<code>replid</code>和<code>offset</code>是自己的<code>replid</code>和<code>offset</code>。</p><p><code>master</code>判断发现<code>slave</code>发送来的<code>replid</code>与自己的不一致，说明这是一个全新的<code>slave</code>，就知道要做全量同步了。</p><p><code>master</code>会将自己的<code>replid</code>和<code>offset</code>都发送给这个<code>slave</code>，<code>slave</code>保存这些信息。以后<code>slave</code>的<code>replid</code>就与<code>master</code>一致了。</p><p>因此，<strong><code>master</code>判断一个节点是否是第一次同步的依据，就是看<code>replid</code>是否一致</strong>。</p><p>如图：</p><p><img src="'+n+'" alt="image-20210725152700914"></p><p>完整流程描述：</p><ul><li><code>slave</code>节点请求增量同步</li><li><code>master</code>节点判断<code>replid</code>，发现不一致，拒绝增量同步</li><li><code>master</code>将完整内存数据生成<code>RDB</code>，发送<code>RDB</code>到<code>slave</code></li><li><code>slave</code>清空本地数据，加载<code>master</code>的<code>RDB</code></li><li><code>master</code>将RDB期间的命令记录在<code>repl_baklog</code>，并持续将<code>log</code>中的命令发送给<code>slave</code></li><li><code>slave</code>执行接收到的命令，保持与<code>master</code>之间的同步</li></ul><h3 id="增量同步" tabindex="-1"><a class="header-anchor" href="#增量同步" aria-hidden="true">#</a> 增量同步</h3><p>全量同步需要先做<code>RDB</code>，然后将<code>RDB</code>文件通过网络传输个<code>slave</code>，成本太高了。因此除了第一次做全量同步，其它大多数时候<code>slave</code>与<code>master</code>都是做<strong>增量同步</strong>。</p><p>什么是增量同步？就是只更新<code>slave</code>与<code>master</code>存在差异的部分数据。如图：</p><p><img src="'+m+'" alt="image-20210725153201086"></p><p>那么<code>master</code>怎么知道<code>slave</code>与自己的数据差异在哪里呢?</p><h3 id="repl-backlog原理" tabindex="-1"><a class="header-anchor" href="#repl-backlog原理" aria-hidden="true">#</a> repl_backlog原理</h3><p><code>master</code>怎么知道<code>slave</code>与自己的数据差异在哪里呢?</p><p>这就要说到全量同步时的<code>repl_baklog</code>文件了。</p><p>这个文件是一个固定大小的数组，只不过数组是环形，也就是说<strong>角标到达数组末尾后，会再次从0开始读写</strong>，这样数组头部的数据就会被覆盖。</p><p><code>repl_baklog</code>中会记录<code>Redis</code>处理过的命令日志及<code>offset</code>，包括<code>master</code>当前的<code>offset</code>，和<code>slave</code>已经拷贝到的<code>offset</code>：</p><p><img src="'+f+'" alt="image-20210725153359022"></p><p><code>slave</code>与<code>master</code>的<code>offset</code>之间的差异，就是<code>salve</code>需要增量拷贝的数据了。</p><p>随着不断有数据写入，<code>master</code>的<code>offset</code>逐渐变大，<code>slave</code>也不断的拷贝，追赶<code>master</code>的<code>offset</code>：</p><p><img src="'+g+'" alt="image-20210725153524190"></p><p>直到数组被填满：</p><p><img src="'+_+'" alt="image-20210725153715910"></p><p>此时，如果有新的数据写入，就会覆盖数组中的旧数据。不过，旧的数据只要是绿色的，说明是已经被同步到<code>slave</code>的数据，即便被覆盖了也没什么影响。因为未同步的仅仅是红色部分。</p><p>但是，如果<code>slave</code>出现网络阻塞，导致<code>master</code>的<code>offset</code>远远超过了<code>slave</code>的<code>offset</code>：</p><p><img src="'+u+'" alt="image-20210725153937031"></p><p>如果<code>master</code>继续写入新数据，其<code>offset</code>就会覆盖旧的数据，直到将<code>slave</code>现在的<code>offset</code>也覆盖：</p><p><img src="'+h+'" alt="image-20210725154155984"></p><p>棕色框中的红色部分，就是尚未同步，但是却已经被覆盖的数据。此时如果<code>slave</code>恢复，需要同步，却发现自己的<code>offset</code>都没有了，无法完成增量同步了。只能做全量同步。</p><p><img src="'+v+'" alt="image-20210725154216392"></p><h2 id="主从同步优化" tabindex="-1"><a class="header-anchor" href="#主从同步优化" aria-hidden="true">#</a> 主从同步优化</h2><p>主从同步可以保证主从数据的一致性，非常重要。</p><p>可以从以下几个方面来优化<code>Redis</code>主从集群：</p><ul><li>在<code>master</code>中配置<code>repl-diskless-sync yes</code>启用无磁盘复制，避免全量同步时的磁盘IO。</li><li><code>Redis</code>单节点上的内存占用不要太大，减少<code>RDB</code>导致的过多磁盘IO</li><li>适当提高<code>repl_baklog</code>的大小，发现<code>slave</code>宕机时尽快实现故障恢复，尽可能避免全量同步</li><li>限制一个<code>master</code>上的<code>slave</code>节点数量，如果实在是太多<code>slave</code>，则可以采用主-从-从链式结构，减少<code>master</code>压力</li></ul><p>主从从架构图：</p><p><img src="'+b+'" alt="image-20210725154405899"></p><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h2><p>简述全量同步和增量同步区别？</p><ul><li>全量同步：<code>master</code>将完整内存数据生成<code>RDB</code>，发送<code>RDB</code>到<code>slave</code>。后续命令则记录在<code>repl_baklog</code>，逐个发送给<code>slave</code>。</li><li>增量同步：<code>slave</code>提交自己的<code>offset</code>到<code>master</code>，<code>master</code>获取<code>repl_baklog</code>中从<code>offset</code>之后的命令给<code>slave</code></li></ul><p>什么时候执行全量同步？</p><ul><li><code>slave</code>节点第一次连接<code>master</code>节点时</li><li><code>slave</code>节点断开时间太久，<code>repl_baklog</code>中的<code>offset</code>已经被覆盖时</li></ul><p>什么时候执行增量同步？</p><ul><li><code>slave</code>节点断开又恢复，并且在<code>repl_baklog</code>中能找到<code>offset</code>时</li></ul>',52);function x(B,D){const c=l("router-link");return t(),r("div",null,[N,e("nav",R,[e("ul",null,[e("li",null,[d(c,{to:"#主从数据同步原理"},{default:a(()=>[o("主从数据同步原理")]),_:1}),e("ul",null,[e("li",null,[d(c,{to:"#全量同步"},{default:a(()=>[o("全量同步")]),_:1})]),e("li",null,[d(c,{to:"#增量同步"},{default:a(()=>[o("增量同步")]),_:1})]),e("li",null,[d(c,{to:"#repl-backlog原理"},{default:a(()=>[o("repl_backlog原理")]),_:1})])])]),e("li",null,[d(c,{to:"#主从同步优化"},{default:a(()=>[o("主从同步优化")]),_:1})]),e("li",null,[d(c,{to:"#小结"},{default:a(()=>[o("小结")]),_:1})])])]),S])}const V=s(k,[["render",x],["__file","DataSynchronization.html.vue"]]);export{V as default};
