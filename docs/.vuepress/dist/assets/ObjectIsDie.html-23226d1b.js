import{_ as i,M as c,p as d,q as s,R as e,N as l,V as t,t as a,a1 as n}from"./framework-5866ffd3.js";const r="/FullStackNotes/assets/image-20230408173150784-c2a3af04.png",p="/FullStackNotes/assets/image-20230408173246584-dcaa7dec.png",h="/FullStackNotes/assets/image-20230408173507408-69e4ba4f.png",_={},u=e("h1",{id:"目录",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#目录","aria-hidden":"true"},"#"),a(" 目录")],-1),f={class:"table-of-contents"},m=n('<h2 id="jvm垃圾回收机制" tabindex="-1"><a class="header-anchor" href="#jvm垃圾回收机制" aria-hidden="true">#</a> JVM垃圾回收机制</h2><p>垃圾回收，就是通过垃圾收集器把内存中没用的对象清理掉。</p><p>垃圾回收涉及到的内容有：</p><ol><li>判断对象是否已死；</li><li>选择垃圾收集算法；</li><li>选择垃圾收集的时间；</li><li>选择适当的垃圾收集器清理垃圾 （已死的对象）;</li></ol><h2 id="判断对象是否已死" tabindex="-1"><a class="header-anchor" href="#判断对象是否已死" aria-hidden="true">#</a> 判断对象是否已死</h2><p>判断对象是否已死有引用计数算法和可达性分析算法。</p><h3 id="_1-引用计数算法" tabindex="-1"><a class="header-anchor" href="#_1-引用计数算法" aria-hidden="true">#</a> （1）引用计数算法</h3><p>给每一个对象添加一个引用计数器，每当有一个地方引用它时，计数器值加 1；</p><p>每当有一个地方不再引用它时，计 数器值减 1；</p><p>这样只要计数器的值不为 0，就说明还有地方引用它，它就不是无用的对象。</p><p><img src="'+r+'" alt="image-20230408173150784"></p><blockquote><p>这种方法看起来非常简单，但目前许多主流的虚拟机都没有选用这种算法来管理内存</p><p>原因就是当某些对象之间互 相引用时，无法判断出这些对象是否已死</p></blockquote><p><img src="'+p+'" alt="image-20230408173246584"></p><h3 id="_2-可达性分析算法" tabindex="-1"><a class="header-anchor" href="#_2-可达性分析算法" aria-hidden="true">#</a> （2）可达性分析算法</h3><p>了解可达性分析算法之前先了解一个概念——<code>GC Roots</code> 垃圾收集的起点</p><p>可以作为 <code>GC Roots</code> 的有</p><ul><li>虚拟机栈中本地变量表中引用的对象</li><li>方法区中静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中 JNI（Native 方 法）引用的对象</li></ul><p>当一个对象到 <code>GC Roots</code> 没有任何引用链相连（<code>GC Roots</code> 到这个对象不可达）时，就说明此对象是不可用的，是死对象</p><p><img src="'+h+'" alt="image-20230408173507408"></p><p>上面被判了死刑的对象（object5、object6、object7）并不是必死无疑，还有挽救的余地。</p><p>进行可达性分析后对象和 <code>GC Roots</code> 之间没有引用链相连时，对象将会被进行一次标记，接着会判断如果对象没有覆盖 <code>Object</code>的 <code>finalize()</code> 方法或者 <code>finalize()</code> 方法已经被虚拟机调用过，那么它们就会被行刑（清除）；</p><p>如果对象覆盖了 <code>finalize()</code> 方法且还没有被调用，则会执行 <code>finalize()</code> 方法中的内容，所以在 <code>finalize()</code> 方法中如果重新与 <code>GC Roots</code> 引用链上的对象关联就可以拯救自己，但是一般不建议这么做</p><blockquote><p>建议大家完全可以忘掉这个方法</p></blockquote><h3 id="_3-方法区回收" tabindex="-1"><a class="header-anchor" href="#_3-方法区回收" aria-hidden="true">#</a> （3）方法区回收</h3><p>上面说的都是对堆内存中对象的判断，方法区中主要回收的是废弃的常量和无用的类。</p><p>判断常量是否废弃可以判断是否有地方引用这个常量，如果没有引用则为废弃的常量。</p><p>判断类是否废弃需要同时满足如下条件：</p><ul><li>该类所有的实例已经被回收（堆中不存在任何该类的实例）。</li><li>加载该类的 ClassLoader 已经被回收。</li><li>该类对应的 <code>java.lang.Class</code> 对象在任何地方没有被引用（无法通过反射访问该类的方法）。</li></ul>',28);function b(g,k){const o=c("router-link");return d(),s("div",null,[u,e("nav",f,[e("ul",null,[e("li",null,[l(o,{to:"#jvm垃圾回收机制"},{default:t(()=>[a("JVM垃圾回收机制")]),_:1})]),e("li",null,[l(o,{to:"#判断对象是否已死"},{default:t(()=>[a("判断对象是否已死")]),_:1}),e("ul",null,[e("li",null,[l(o,{to:"#_1-引用计数算法"},{default:t(()=>[a("（1）引用计数算法")]),_:1})]),e("li",null,[l(o,{to:"#_2-可达性分析算法"},{default:t(()=>[a("（2）可达性分析算法")]),_:1})]),e("li",null,[l(o,{to:"#_3-方法区回收"},{default:t(()=>[a("（3）方法区回收")]),_:1})])])])])]),m])}const j=i(_,[["render",b],["__file","ObjectIsDie.html.vue"]]);export{j as default};
