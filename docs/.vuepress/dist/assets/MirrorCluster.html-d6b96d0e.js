import{_ as d,M as i,p as s,q as u,R as t,N as o,V as l,t as e,a1 as n}from"./framework-5866ffd3.js";const c="/FullStackNotes/assets/image-20210718221039542-34311eab.png",r="/FullStackNotes/assets/image-20210717231751411-68caad2e.png",q="/FullStackNotes/assets/image-20210717231829505-42ca3232.png",h="/FullStackNotes/assets/image-20210717231958996-edd09826.png",m="/FullStackNotes/assets/image-20210717232108584-ad9930ae.png",p="/FullStackNotes/assets/image-20210717232257420-2e73e273.png",b="/FullStackNotes/assets/image-20210717232322646-fbbc47dd.png",g={},x=t("h1",{id:"目录",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#目录","aria-hidden":"true"},"#"),e(" 目录")],-1),_={class:"table-of-contents"},f=n('<h2 id="镜像集群" tabindex="-1"><a class="header-anchor" href="#镜像集群" aria-hidden="true">#</a> 镜像集群</h2><h3 id="集群结构和特征" tabindex="-1"><a class="header-anchor" href="#集群结构和特征" aria-hidden="true">#</a> 集群结构和特征</h3><p>镜像集群：本质是主从模式，具备下面的特征：</p><ul><li>交换机、队列、队列中的消息会在各个<code>mq</code>的镜像节点之间同步备份。</li><li>创建队列的节点被称为该队列的<strong>主节点，<strong>备份到的其它节点叫做该队列的</strong>镜像</strong>节点。</li><li>一个队列的主节点可能是另一个队列的镜像节点</li><li>所有操作都是主节点完成，然后同步给镜像节点</li><li>主宕机后，镜像节点会替代成新的主</li><li>当主节点接收到消费者的ACK时，所有镜像都会删除节点中的数据。</li></ul><p>结构如图：</p><p><img src="'+c+`" alt="image-20210718221039542"></p><h3 id="部署" tabindex="-1"><a class="header-anchor" href="#部署" aria-hidden="true">#</a> 部署</h3><p>镜像模式的配置有3种模式</p><table><thead><tr><th style="text-align:left;">ha-mode</th><th style="text-align:left;">ha-params</th><th style="text-align:left;">效果</th></tr></thead><tbody><tr><td style="text-align:left;">准确模式exactly</td><td style="text-align:left;">队列的副本量count</td><td style="text-align:left;">集群中队列副本（主服务器和镜像服务器之和）的数量。count如果为1意味着单个副本：即队列主节点。count值为2表示2个副本：1个队列主和1个队列镜像。换句话说：count = 镜像数量 + 1。如果群集中的节点数少于count，则该队列将镜像到所有节点。如果有集群总数大于count+1，并且包含镜像的节点出现故障，则将在另一个节点上创建一个新的镜像。</td></tr><tr><td style="text-align:left;">all</td><td style="text-align:left;">(none)</td><td style="text-align:left;">队列在群集中的所有节点之间进行镜像。队列将镜像到任何新加入的节点。镜像到所有节点将对所有群集节点施加额外的压力，包括网络I / O，磁盘I / O和磁盘空间使用情况。推荐使用exactly，设置副本数为（N / 2 +1）。</td></tr><tr><td style="text-align:left;">nodes</td><td style="text-align:left;"><em>node names</em></td><td style="text-align:left;">指定队列创建到哪些节点，如果指定的节点全部不存在，则会出现异常。如果指定的节点在集群中存在，但是暂时不可用，会创建节点到当前客户端连接到的节点。</td></tr></tbody></table><p>以rabbitmqctl命令作为配置语法。</p><p>语法示例：</p><h3 id="exactly模式" tabindex="-1"><a class="header-anchor" href="#exactly模式" aria-hidden="true">#</a> exactly模式</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>rabbitmqctl set_policy ha-two &quot;^two\\.&quot; &#39;{&quot;ha-mode&quot;:&quot;exactly&quot;,&quot;ha-params&quot;:2,&quot;ha-sync-mode&quot;:&quot;automatic&quot;}&#39;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><code>rabbitmqctl set_policy</code>：固定写法</li><li><code>ha-two</code>：策略名称，自定义</li><li><code>&quot;^two\\.&quot;</code>：匹配队列的正则表达式，符合命名规则的队列才生效，这里是任何以<code>two.</code>开头的队列名称</li><li><code>&#39;{&quot;ha-mode&quot;:&quot;exactly&quot;,&quot;ha-params&quot;:2,&quot;ha-sync-mode&quot;:&quot;automatic&quot;}&#39;</code>: 策略内容 <ul><li><code>&quot;ha-mode&quot;:&quot;exactly&quot;</code>：策略模式，此处是exactly模式，指定副本数量</li><li><code>&quot;ha-params&quot;:2</code>：策略参数，这里是2，就是副本数量为2，1主1镜像</li><li><code>&quot;ha-sync-mode&quot;:&quot;automatic&quot;</code>：同步策略，默认是manual，即新加入的镜像节点不会同步旧的消息。如果设置为<code>automatic</code>，则新加入的镜像节点会把主节点中所有消息都同步，会带来额外的网络开销</li></ul></li></ul><h3 id="all模式" tabindex="-1"><a class="header-anchor" href="#all模式" aria-hidden="true">#</a> all模式</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>rabbitmqctl set_policy ha-all &quot;^all\\.&quot; &#39;{&quot;ha-mode&quot;:&quot;all&quot;}&#39;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><code>ha-all</code>：策略名称，自定义</li><li><code>&quot;^all\\.&quot;</code>：匹配所有以<code>all.</code>开头的队列名</li><li><code>&#39;{&quot;ha-mode&quot;:&quot;all&quot;}&#39;</code>：策略内容 <ul><li><code>&quot;ha-mode&quot;:&quot;all&quot;</code>：策略模式，此处是all模式，即所有节点都会称为镜像节点</li></ul></li></ul><h3 id="nodes模式" tabindex="-1"><a class="header-anchor" href="#nodes模式" aria-hidden="true">#</a> nodes模式</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>rabbitmqctl set_policy ha-nodes &quot;^nodes\\.&quot; &#39;{&quot;ha-mode&quot;:&quot;nodes&quot;,&quot;ha-params&quot;:[&quot;rabbit@nodeA&quot;, &quot;rabbit@nodeB&quot;]}&#39;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><code>rabbitmqctl set_policy</code>：固定写法</li><li><code>ha-nodes</code>：策略名称，自定义</li><li><code>&quot;^nodes\\.&quot;</code>：匹配队列的正则表达式，符合命名规则的队列才生效，这里是任何以<code>nodes.</code>开头的队列名称</li><li><code>&#39;{&quot;ha-mode&quot;:&quot;nodes&quot;,&quot;ha-params&quot;:[&quot;rabbit@nodeA&quot;, &quot;rabbit@nodeB&quot;]}&#39;</code>: 策略内容 <ul><li><code>&quot;ha-mode&quot;:&quot;nodes&quot;</code>：策略模式，此处是nodes模式</li><li><code>&quot;ha-params&quot;:[&quot;rabbit@mq1&quot;, &quot;rabbit@mq2&quot;]</code>：策略参数，这里指定副本所在节点名称</li></ul></li></ul><h3 id="测试" tabindex="-1"><a class="header-anchor" href="#测试" aria-hidden="true">#</a> 测试</h3><p>我们使用<code>exactly</code>模式的镜像，因为集群节点数量为3，因此镜像数量就设置为2.</p><p>运行下面的命令：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> mq1 rabbitmqctl set_policy ha-two <span class="token string">&quot;^two\\.&quot;</span> <span class="token string">&#39;{&quot;ha-mode&quot;:&quot;exactly&quot;,&quot;ha-params&quot;:2,&quot;ha-sync-mode&quot;:&quot;automatic&quot;}&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>下面，我们创建一个新的队列：</p><p><img src="`+r+'" alt="image-20210717231751411"></p><p>在任意一个mq控制台查看队列：</p><p><img src="'+q+'" alt="image-20210717231829505"></p><h3 id="测试数据共享" tabindex="-1"><a class="header-anchor" href="#测试数据共享" aria-hidden="true">#</a> 测试数据共享</h3><p>给two.queue发送一条消息：</p><p><img src="'+h+'" alt="image-20210717231958996"></p><p>然后在mq1、mq2、mq3的任意控制台查看消息：</p><p><img src="'+m+`" alt="image-20210717232108584"></p><h3 id="测试高可用" tabindex="-1"><a class="header-anchor" href="#测试高可用" aria-hidden="true">#</a> 测试高可用</h3><p>现在，我们让two.queue的主节点mq1宕机：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> stop mq1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>查看集群状态：</p><p><img src="`+p+'" alt="image-20210717232257420"></p><p>查看队列状态：</p><p><img src="'+b+'" alt="image-20210717232322646"></p><p>发现依然是健康的！并且其主节点切换到了rabbit@mq2上</p>',41);function y(v,k){const a=i("router-link");return s(),u("div",null,[x,t("nav",_,[t("ul",null,[t("li",null,[o(a,{to:"#镜像集群"},{default:l(()=>[e("镜像集群")]),_:1}),t("ul",null,[t("li",null,[o(a,{to:"#集群结构和特征"},{default:l(()=>[e("集群结构和特征")]),_:1})]),t("li",null,[o(a,{to:"#部署"},{default:l(()=>[e("部署")]),_:1})]),t("li",null,[o(a,{to:"#exactly模式"},{default:l(()=>[e("exactly模式")]),_:1})]),t("li",null,[o(a,{to:"#all模式"},{default:l(()=>[e("all模式")]),_:1})]),t("li",null,[o(a,{to:"#nodes模式"},{default:l(()=>[e("nodes模式")]),_:1})]),t("li",null,[o(a,{to:"#测试"},{default:l(()=>[e("测试")]),_:1})]),t("li",null,[o(a,{to:"#测试数据共享"},{default:l(()=>[e("测试数据共享")]),_:1})]),t("li",null,[o(a,{to:"#测试高可用"},{default:l(()=>[e("测试高可用")]),_:1})])])])])]),f])}const w=d(g,[["render",y],["__file","MirrorCluster.html.vue"]]);export{w as default};
