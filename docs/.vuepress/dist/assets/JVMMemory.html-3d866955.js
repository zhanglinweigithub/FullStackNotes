import{_ as d,M as o,p as r,q as c,R as e,N as t,V as i,t as a,a1 as n}from"./framework-5866ffd3.js";const h="/FullStackNotes/assets/image-20230408162038562-456aa605.png",s="/FullStackNotes/assets/image-20230408163057563-a4078bfb.png",p={},u=e("h1",{id:"目录",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#目录","aria-hidden":"true"},"#"),a(" 目录")],-1),_={class:"table-of-contents"},f=n('<h2 id="jvm内存区域" tabindex="-1"><a class="header-anchor" href="#jvm内存区域" aria-hidden="true">#</a> JVM内存区域</h2><p><code>Java</code>虚拟机在运行时，会把内存空间分为若干个区域</p><p>Java虚拟机所管理的内存区域分为如下部分：</p><ul><li>方法区</li><li>堆内存：存放对象和数组 <ul><li>年轻代</li><li>老年代</li><li>永久代（方法区）</li></ul></li><li>虚拟机栈</li><li>本地方法栈</li><li>程序计数器</li></ul><p><img src="'+h+'" alt="image-20230408162038562"></p><h2 id="方法区" tabindex="-1"><a class="header-anchor" href="#方法区" aria-hidden="true">#</a> 方法区</h2><p>用于存储虚拟机加载的类信息、常量、静态变量，以及编译器编译后的代码等数据</p><blockquote><p><code>jdk1.8</code>中，方法区已经不存在，原方法区中存储的类信息、编译后的代码数据等已经移动到了元空间</p></blockquote><p>元空间并没有处于堆内存上，而是直接占用的本地内存</p><p><img src="'+s+'" alt="image-20230408163057563"></p><h3 id="去除永久代的原因" tabindex="-1"><a class="header-anchor" href="#去除永久代的原因" aria-hidden="true">#</a> 去除永久代的原因</h3><p>（1）字符串存在永久代中，容易出现性能问题和内存溢出。</p><p>（2）类及方法的信息等比较难确定其大小，因此对 于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。</p><p>（3）永久代会为 <code>GC</code> 带来不必要的复杂度，并且回收效率偏低</p><h2 id="堆内存" tabindex="-1"><a class="header-anchor" href="#堆内存" aria-hidden="true">#</a> 堆内存</h2><p>存放我们在代码中创建的各种对象</p><p>堆还可以分为</p><ul><li>新生代（YoungGeneration）</li><li>老年代（OldGeneration）</li></ul><h2 id="虚拟机栈" tabindex="-1"><a class="header-anchor" href="#虚拟机栈" aria-hidden="true">#</a> 虚拟机栈</h2><p>调用执行任何方法时，都会给方法创建栈帧然后入栈, 方法执行完毕之后就出栈</p><p>每个线程都有自己的Java虚拟机栈</p><h2 id="本地方法栈" tabindex="-1"><a class="header-anchor" href="#本地方法栈" aria-hidden="true">#</a> 本地方法栈</h2><p>本地方法栈与虚拟机栈的区别是，虚拟机栈执行的是 <code>Java</code> 方法，本地方法栈执行的是本地方法（<code>Native Method</code>）</p><h2 id="程序计数器" tabindex="-1"><a class="header-anchor" href="#程序计数器" aria-hidden="true">#</a> 程序计数器</h2><p>程序计数器就是用来记录当前执行的字节码指令的位置的，也就是记录目前执行到了哪一条字节码指令</p><p>每个线程都有一个独立的程序计数器</p><p>程序计数器是<code>Java</code>虚拟机规定的唯一不会发生内存溢出 的区域</p><h2 id="元空间" tabindex="-1"><a class="header-anchor" href="#元空间" aria-hidden="true">#</a> 元空间</h2><p><code>jdk1.8</code> 中，已经不存在永久代（方法区），替代它的一块空间叫做 “ 元空间 ”</p><p>和永久代类似，都是 <code>JVM</code> 规范对方法区的实现，但是元空间并不在虚拟机中，而是使用本地内存，元空间的大小仅受本地内存限制，但 可以通过 -<code>XX:MetaspaceSize</code> 和 <code>-XX:MaxMetaspaceSize</code> 来指定元空间的大小。</p>',30);function m(x,b){const l=o("router-link");return r(),c("div",null,[u,e("nav",_,[e("ul",null,[e("li",null,[t(l,{to:"#jvm内存区域"},{default:i(()=>[a("JVM内存区域")]),_:1})]),e("li",null,[t(l,{to:"#方法区"},{default:i(()=>[a("方法区")]),_:1}),e("ul",null,[e("li",null,[t(l,{to:"#去除永久代的原因"},{default:i(()=>[a("去除永久代的原因")]),_:1})])])]),e("li",null,[t(l,{to:"#堆内存"},{default:i(()=>[a("堆内存")]),_:1})]),e("li",null,[t(l,{to:"#虚拟机栈"},{default:i(()=>[a("虚拟机栈")]),_:1})]),e("li",null,[t(l,{to:"#本地方法栈"},{default:i(()=>[a("本地方法栈")]),_:1})]),e("li",null,[t(l,{to:"#程序计数器"},{default:i(()=>[a("程序计数器")]),_:1})]),e("li",null,[t(l,{to:"#元空间"},{default:i(()=>[a("元空间")]),_:1})])])]),f])}const M=d(p,[["render",m],["__file","JVMMemory.html.vue"]]);export{M as default};
