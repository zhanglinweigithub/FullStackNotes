import{_ as o,M as d,p as c,q as l,R as a,N as n,V as t,t as e,a1 as i}from"./framework-5866ffd3.js";const p={},r=a("h1",{id:"目录",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#目录","aria-hidden":"true"},"#"),e(" 目录")],-1),u={class:"table-of-contents"},h=i(`<h2 id="dao-接口里的方法-参数不同时能重载吗" tabindex="-1"><a class="header-anchor" href="#dao-接口里的方法-参数不同时能重载吗" aria-hidden="true">#</a> Dao 接口里的方法，参数不同时能重载吗</h2><p>不能重载。</p><p>因为 <code>xml</code> 中的<code>id</code>和方法名是对应的，如果方法重载了，那就对应会出现两个相同的<code>id</code>，在 <code>xml</code> 中会报错 的。</p><p>再往深的说，在<code>MyBatis</code>源码中，会以方法名为<code>key</code>（也就是xml中的id），存放在<code>map</code>中，<code>map</code>的<code>key</code>是不能 重复的。</p><h2 id="不同的-xml-映射文件-id是否可以重复" tabindex="-1"><a class="header-anchor" href="#不同的-xml-映射文件-id是否可以重复" aria-hidden="true">#</a> 不同的 xml 映射文件，id是否可以重复</h2><p>不同的 <code>xml</code> 映射文件，如果配置了 <code>namespace</code> ，那么<code>id</code>可以重复；</p><p>如果没有配置<code>namespace</code>，那么<code>id</code>不能重复；</p><p>原因就是 <code>namespace+id</code> 是作为 <code>Map</code> 的<code>key</code>使用的，如果没有 <code>namespace</code> ，就剩下<code>id</code>， 那么，<code>id</code>重复会导致数据互相覆盖。</p><p>有了 <code>namespace</code> ，自然<code>id</code>就可以重复， <code>namespace</code> 不同， <code>namespace+id</code> 自然 也就不同。</p><h2 id="和-的区别是什么" tabindex="-1"><a class="header-anchor" href="#和-的区别是什么" aria-hidden="true">#</a> #{} 和 \${} 的区别是什么</h2><p><code>\\#{}</code>:为参数占位符 <code>？</code>，即<code>sql</code>预编译，将<code>sql</code> 中的 <code>#{}</code> 替换为 <code>?</code> 号 ，然后对他进行赋值，可以 防止<code>sql</code>注入</p><p><code>\${}</code>:为字符串替换， 就是把 <code>{}</code> 直接替换成变量的值，不能防止<code>sql</code>注入。</p><h2 id="当实体类中的属性名和表中的字段名不一样时怎么办" tabindex="-1"><a class="header-anchor" href="#当实体类中的属性名和表中的字段名不一样时怎么办" aria-hidden="true">#</a> 当实体类中的属性名和表中的字段名不一样时怎么办</h2><p>**第 1 种：**定义别名</p><p>​ 通过在查询的 sql 语句中定义字段名的别名，让字段名的别名和实体类的属性名一致</p><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>selectById<span class="token punctuation">&quot;</span></span> <span class="token attr-name">resultMap</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>User<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
	select id, name as userName, pwd as password from m_user
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>where</span><span class="token punctuation">&gt;</span></span>
		<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>id != null<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
			id = #{id}
		<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>where</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>**第 2 种：**通过 来映射字段名和实体类属性名的一一对应的关系</p><p>**第 3 种：**使用注解时候，使用Result，和第二种类似</p><h2 id="mybatis-的手动编程步骤" tabindex="-1"><a class="header-anchor" href="#mybatis-的手动编程步骤" aria-hidden="true">#</a> MyBatis 的手动编程步骤</h2><ol><li>创建 SqlSessionFactory</li><li>通过 SqlSessionFactory 创建 SqlSession</li><li>通过 sqlsession 执行数据库操作</li><li>调用 session.commit()提交事务</li><li>调用 session.close()关闭会话</li></ol><h2 id="mybatis-工作的流程" tabindex="-1"><a class="header-anchor" href="#mybatis-工作的流程" aria-hidden="true">#</a> MyBatis 工作的流程</h2><p>1.加载配置并初始化</p><p>2.接收调用请求</p><p>3.处理操作请求 触发条件</p><p>4.返回处理结果</p><h2 id="增删改返回值说明" tabindex="-1"><a class="header-anchor" href="#增删改返回值说明" aria-hidden="true">#</a> 增删改返回值说明</h2><p>插入成功1行返回结果就是1，删除了10行记录，返回就是10，更新了5行记录，返回的就是 5</p><h2 id="mapper接口的原理" tabindex="-1"><a class="header-anchor" href="#mapper接口的原理" aria-hidden="true">#</a> Mapper接口的原理</h2><p>使用<code>java</code>中的动态代理实现的，<code>mybatis</code>启动的时候会加载全局配置文件</p><p>然后解析这个文件中的 <code>mapper</code>元素指定的UserMapper.xml ，会根据 UserMapper.xml的<code>namespace</code>的 值 创建这个接口的一个动态代理</p><p>主要使用<code>java</code>中的<code>Proxy</code>实现的， 使用 <code>java.lang.reflect.Proxy</code> 类中的 <code>newProxyInstance</code> 方法，我们可以创建任意一个接口的一个 代理对象</p><h2 id="mybatis分页" tabindex="-1"><a class="header-anchor" href="#mybatis分页" aria-hidden="true">#</a> MyBatis分页</h2><p><code>MyBatis</code> 使用<code>RowBounds</code>对象进行分页，它是针对<code>ResultSet</code>结果集执行的内存分页，而非物理分页，先把数据都 查出来，然后再做分页</p><p>可以在<code>sql</code>内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页</p><h2 id="分页插件的基本原理" tabindex="-1"><a class="header-anchor" href="#分页插件的基本原理" aria-hidden="true">#</a> 分页插件的基本原理？</h2><p>使用<code>Mybatis</code>提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的<code>sql</code>，然后重写<code>sql</code>根据<code>dialect</code>方言，添加对应的物理分页语句和物理分页参数</p><h2 id="简述mybatis的插件运行原理" tabindex="-1"><a class="header-anchor" href="#简述mybatis的插件运行原理" aria-hidden="true">#</a> 简述Mybatis的插件运行原理？</h2><p><code>MyBatis</code> 仅可以编写针对<code>ParameterHandler</code>、<code>ResultSetHandler</code>、<code>StatementHandler</code>、<code>Executor</code>这4种接口的插件</p><p><code>MyBatis</code> 使用<code>JDK</code>的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是<code>InvocationHandler</code>的<code>invoke()</code>方法，当然，只会拦截那些你指定需要拦截的方法</p>`,39);function m(k,b){const s=d("router-link");return c(),l("div",null,[r,a("nav",u,[a("ul",null,[a("li",null,[n(s,{to:"#dao-接口里的方法-参数不同时能重载吗"},{default:t(()=>[e("Dao 接口里的方法，参数不同时能重载吗")]),_:1})]),a("li",null,[n(s,{to:"#不同的-xml-映射文件-id是否可以重复"},{default:t(()=>[e("不同的 xml 映射文件，id是否可以重复")]),_:1})]),a("li",null,[n(s,{to:"#和-的区别是什么"},{default:t(()=>[e("#{} 和 ${} 的区别是什么")]),_:1})]),a("li",null,[n(s,{to:"#当实体类中的属性名和表中的字段名不一样时怎么办"},{default:t(()=>[e("当实体类中的属性名和表中的字段名不一样时怎么办")]),_:1})]),a("li",null,[n(s,{to:"#mybatis-的手动编程步骤"},{default:t(()=>[e("MyBatis 的手动编程步骤")]),_:1})]),a("li",null,[n(s,{to:"#mybatis-工作的流程"},{default:t(()=>[e("MyBatis 工作的流程")]),_:1})]),a("li",null,[n(s,{to:"#增删改返回值说明"},{default:t(()=>[e("增删改返回值说明")]),_:1})]),a("li",null,[n(s,{to:"#mapper接口的原理"},{default:t(()=>[e("Mapper接口的原理")]),_:1})]),a("li",null,[n(s,{to:"#mybatis分页"},{default:t(()=>[e("MyBatis分页")]),_:1})]),a("li",null,[n(s,{to:"#分页插件的基本原理"},{default:t(()=>[e("分页插件的基本原理？")]),_:1})]),a("li",null,[n(s,{to:"#简述mybatis的插件运行原理"},{default:t(()=>[e("简述Mybatis的插件运行原理？")]),_:1})])])]),h])}const f=o(p,[["render",m],["__file","KnowledgePoints.html.vue"]]);export{f as default};
