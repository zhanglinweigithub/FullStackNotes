import{_ as s,M as r,p as c,q as i,R as e,N as n,V as a,t as o,a1 as d}from"./framework-5866ffd3.js";const l="/FullStackNotes/assets/1676527601579-ad90a32f-5df2-492d-9866-84169b559f77-ac319f00.png",g="/FullStackNotes/assets/1676528370730-8c36d5eb-422e-4753-b8bd-0169132ee479-0db75a6c.png",p="/FullStackNotes/assets/1676528791961-07901551-e0a0-48f2-82e2-87a6ba523831-12bdf845.png",B="/FullStackNotes/assets/1676528993968-2a4a48f5-9541-4fe7-89db-4e8d2b5ddb32-809d25db.png",b="/FullStackNotes/assets/1676529564616-9a863de1-cd2e-4767-826d-5ceec4caa447-1a44aabe.png",f="/FullStackNotes/assets/1676529880935-ae999c8c-45a4-4b3d-a2c9-3151f75f53f2-3e1a8894.png",h="/FullStackNotes/assets/1676530037522-e759f94f-47f6-46a2-86ba-2135861bcb13-e9fbd508.png",u="/FullStackNotes/assets/1675489737307-72a4782b-d2fe-4a25-8c50-1e9e5407ebce-7551a3a6.png",_={},m=e("h1",{id:"目录",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#目录","aria-hidden":"true"},"#"),o(" 目录")],-1),P={class:"table-of-contents"},N=d('<h2 id="bean-生命周期" tabindex="-1"><a class="header-anchor" href="#bean-生命周期" aria-hidden="true">#</a> Bean 生命周期</h2><p>当我们向容器请求一个尚未初始化的<code>bean</code>时，或初始化<code>bean</code>的时候需要注入另一个尚未初始化的依赖时，就会开始<code>Bean</code>的生命周期 <strong>实例化 --&gt; 依赖注入 --&gt; 初始化 --&gt; 销毁</strong></p><h3 id="实例化bean" tabindex="-1"><a class="header-anchor" href="#实例化bean" aria-hidden="true">#</a> 实例化Bean</h3><ol><li>首先会调用 <strong>AbstractAutowireCapableBeanFactory</strong> 类的 <strong>doCreateBean</strong> 方法创建<code>bean</code><ol><li>第一步 调用 <strong>createBeanInstance</strong> 方法利用反射创建<code>bean</code>实例</li><li>将创建好的<code>bean</code>放入 <strong>BeanWrapper</strong> 中</li><li>实例化后的对象会利用 <strong>ObjectFactory</strong> 暴露</li></ol></li></ol><p><img src="'+l+'" alt="image.png"></p><h3 id="依赖注入" tabindex="-1"><a class="header-anchor" href="#依赖注入" aria-hidden="true">#</a> 依赖注入</h3><ol><li>调用 <strong>populateBean</strong> 方法对使用到了注入属性的注解就会进行注入</li><li>如果在注入的过程发现注入的对象还没生成，则会跑去生产要注入的对象</li></ol><p><img src="'+g+'" alt="image.png"></p><h3 id="初始化bean" tabindex="-1"><a class="header-anchor" href="#初始化bean" aria-hidden="true">#</a> 初始化bean</h3><p><img src="'+p+'" alt="image.png"></p><ol><li><p>调用 <strong>initializeBean</strong> 方法初始化<code>bean</code></p><p>①首先调用的是 <strong>invokeAwareMethods</strong> 方法，该方法处理 <code>Aware</code> 接口</p><ul><li>如果这个<code>Bean</code>已经实现了 <strong>BeanNameAware</strong> 接口，会调用它实现的 <strong>setBeanName(String beanId)</strong> 方法，此处传 递的就是<code>Spring</code>配置文件中<code>Bean</code>的<code>id</code>值</li><li>如果这个<code>Bean</code>已经实现了 <strong>BeanFactoryAware</strong> 接口，会调用它实现的 <strong>setBeanFactory()</strong> 方法，传递的是<code>Spring</code>工 厂自身。</li><li>如果这个<code>Bean</code>已经实现了 <strong>BeanClassLoaderAware <strong>接口，会调用 s</strong>etBeanClassLoader()</strong> 方法，传入类加载器</li></ul></li></ol><p><img src="'+B+'" alt="image.png"></p><p>​ ②然后调用 <strong>applyBeanPostProcessorsBeforeInitialization</strong> 方法，处理 <strong>BeanPostProcessor</strong> 接口</p><ul><li>如果有类实现了 <strong>BeanPostProcessor</strong> 接口，就会执行 <strong>postProcessBeforeInitialization</strong> 方法</li><li>如果多个类实现<strong>BeanPostProcessor</strong>接口，那么多个实现类都会执行<strong>postProcessBeforeInitialization</strong>方法，可以看到是<code>for</code>循环依次执行的，</li><li>还有一个注意的点就是如果加载<code>A</code>类到<code>spring</code>容器中，<code>A</code>类也重写了 <strong>BeanPostProcessor</strong> 接口的 <strong>postProcessBeforeInitialization</strong> 方法，这时要注意<code>A</code>类的<strong>postProcessBeforeInitialization</strong> 方法并不会得到执行，因为<code>A</code>类还未加载完成，还未完全放到<code>spring</code>的 <strong>singletonObjects</strong> 一级缓存中。</li></ul><p><img src="'+b+'" alt="image.png"></p><p>③然后执行 <strong>invokeInitMethods</strong> 方法</p><ul><li>如果实现了 <strong>InitializingBean</strong> 接口，重写了 <strong>afterPropertiesSet</strong> 方法，则会调用<strong>afterPropertiesSet</strong> 方法</li><li>最后如果指定了 <strong>init-method</strong>，可以通过标签，或者<code>@Bean</code>注解的<code>initMethod</code>指定，则会调用指定的 <strong>init-method</strong> 方法</li></ul><p><img src="'+f+'" alt="image.png"></p><p>④最后会执行 <strong>applyBeanPostProcessorsAfterInitialization</strong> 方法</p><ol><li>跟之前的 <strong>postProcessBeforeInitialization</strong> 方法类似，也是循环遍历实现了<strong>BeanPostProcessor</strong> 的接口实现类，执行 <strong>postProcessAfterInitialization</strong> 方法</li></ol><p><img src="'+h+'" alt="image.png"><strong>至此 Bean初始化完成，可以正常使用</strong></p><p>（1）实例化Bean：</p><ul><li>对于<code>BeanFactory</code>容器，当客户向容器请求一个尚未初始化的<code>bean</code>时，或初始化<code>bean</code>的时候需要注入另一个尚未初始化的依赖时，容器就会调用<code>createBean</code>进行实例化</li><li>对于<code>ApplicationContext</code>容器，当容器启动结束后，通过 获取<code>BeanDefinition</code>对象中的信息，实例化所有的<code>bean</code>。</li></ul><p>（2）依赖注入 实例化后的对象被封装在<code>BeanWrapper</code>对象中，紧接着，<code>Spring</code>根据<code>BeanDefinition</code>中的信息 以及 通过 <code>BeanWrapper</code>提供的设置属性的接口完成依赖注入 （3）初始化 （4）销毁 <code>DisposableBean</code> 接口 当<code>Bean</code>不再需要时，会经过清理阶段，如果<code>Bean</code>实现了<code>DisposableBean</code>这个接口，会调用其实现的<code>destroy()</code>方 法 如果这个<code>Bean</code>配置了<code>destroy-method</code>属性，会自动调用其配置的销毁方法 <img src="'+u+'" alt="image.png"></p>',24);function S(k,A){const t=r("router-link");return c(),i("div",null,[m,e("nav",P,[e("ul",null,[e("li",null,[n(t,{to:"#bean-生命周期"},{default:a(()=>[o("Bean 生命周期")]),_:1}),e("ul",null,[e("li",null,[n(t,{to:"#实例化bean"},{default:a(()=>[o("实例化Bean")]),_:1})]),e("li",null,[n(t,{to:"#依赖注入"},{default:a(()=>[o("依赖注入")]),_:1})]),e("li",null,[n(t,{to:"#初始化bean"},{default:a(()=>[o("初始化bean")]),_:1})])])])])]),N])}const I=s(_,[["render",S],["__file","BeanLifeCycle.html.vue"]]);export{I as default};
