import{_ as d,M as o,p as s,q as r,R as e,N as i,V as t,t as l,a1 as c}from"./framework-5866ffd3.js";const n="/FullStackNotes/assets/1653322097736-291ff444.png",p="/FullStackNotes/assets/1653322506393-7b9fae9d.png",h="/FullStackNotes/assets/1653326156516-74557e93.png",u="/FullStackNotes/assets/1653327884526-1674300f.png",_="/FullStackNotes/assets/1653328022622-42d0fd7a.png",g="/FullStackNotes/assets/1653328288627-a0cc94c2.png",f="/FullStackNotes/assets/1653328663897-73da8bb1.png",m="/FullStackNotes/assets/1653357522914-aac9dd71.png",x={},b=e("h1",{id:"目录",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#目录","aria-hidden":"true"},"#"),l(" 目录")],-1),k={class:"table-of-contents"},N=c('<h2 id="缓存" tabindex="-1"><a class="header-anchor" href="#缓存" aria-hidden="true">#</a> 缓存</h2><h3 id="缓存模型和思路" tabindex="-1"><a class="header-anchor" href="#缓存模型和思路" aria-hidden="true">#</a> 缓存模型和思路</h3><p>标准的操作方式就是查询数据库之前先查询缓存，如果缓存数据存在，则直接从缓存中返回，如果缓存数据不存在，再查询数据库，然后将数据存入<code>redis</code>。</p><p><img src="'+n+'" alt="1653322097736"></p><h3 id="缓存更新策略" tabindex="-1"><a class="header-anchor" href="#缓存更新策略" aria-hidden="true">#</a> 缓存更新策略</h3><p><strong>内存淘汰：</strong><code>redis</code>自动进行，当<code>redis</code>内存达到咱们设定的<code>max-memery</code>的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)</p><p><strong>超时剔除：</strong> 当我们给<code>redis</code>设置了过期时间<code>ttl</code>之后，<code>redis</code>会将超时的数据进行删除，方便咱们继续使用缓存</p><p><strong>主动更新：</strong> 我们可以手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题</p><p><img src="'+p+'" alt="1653322506393"></p><h2 id="数据库缓存不一致解决方案" tabindex="-1"><a class="header-anchor" href="#数据库缓存不一致解决方案" aria-hidden="true">#</a> 数据库缓存不一致解决方案</h2><ul><li><strong>Cache Aside Pattern</strong> ：人工编码方式，缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案</li><li><strong>Read/Write Through Pattern</strong> : 由系统本身完成，数据库与缓存的问题交由系统本身去处理</li><li><strong>Write Behind Caching Pattern</strong> ：调用者只操作缓存，其他线程去异步处理数据库，实现最终一致</li></ul><p><strong>综合考虑使用方案一</strong></p><ul><li><p>删除缓存还是更新缓存？</p><ul><li>更新缓存：每次更新数据库都更新缓存，无效写操作较多</li><li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存</li></ul></li><li><p>如何保证缓存与数据库的操作的同时成功或失败？</p><ul><li>单体系统，将缓存与数据库操作放在一个事务</li><li>分布式系统，利用TCC等分布式事务方案</li></ul></li><li><p>先操作缓存还是先操作数据库？</p><ul><li>先删除缓存，再操作数据库</li><li>先操作数据库，再删除缓存</li></ul></li></ul><p>应当是先操作数据库，再删除缓存</p><p>原因在于，如果你选择第一种方案，在两个线程并发来访问时，假设线程1先来，他先把缓存删了，此时线程2过来，他查询缓存数据并不存在，此时他写入缓存，当他写入缓存后，线程1再执行更新动作时，实际上写入的就是旧的数据，新的数据被旧数据覆盖了。</p><h3 id="缓存与数据库双写一致" tabindex="-1"><a class="header-anchor" href="#缓存与数据库双写一致" aria-hidden="true">#</a> 缓存与数据库双写一致</h3><p>核心思路如下：</p><p>根据id查询店铺时，如果缓存未命中，则查询数据库，将数据库结果写入缓存，并设置超时时间</p><p>根据id修改店铺时，先修改数据库，再删除缓存</p><h2 id="缓存穿透问题的解决思路" tabindex="-1"><a class="header-anchor" href="#缓存穿透问题的解决思路" aria-hidden="true">#</a> 缓存穿透问题的解决思路</h2><p><strong>缓存穿透</strong> ：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p><p>常见的解决方案有两种：</p><ul><li>缓存空对象 <ul><li>优点：实现简单，维护方便</li><li>缺点： <ul><li>额外的内存消耗</li><li>可能造成短期的不一致</li></ul></li></ul></li><li>布隆过滤 <ul><li>优点：内存占用较少，没有多余key</li><li>缺点： <ul><li>实现复杂</li><li>存在误判可能</li></ul></li></ul></li></ul><h3 id="缓存空对象" tabindex="-1"><a class="header-anchor" href="#缓存空对象" aria-hidden="true">#</a> 缓存空对象</h3><p>当我们客户端访问不存在的数据时，先请求<code>redis</code>，但是此时<code>redis</code>中没有数据，此时会访问到数据库，但是数据库中也没有数据</p><p>此时我们在<code>redis</code>中存入一个空对象，这样，下次用户过来访问这个不存在的数据，那么在<code>redis</code>中也能找到这个数据就不会进入到数据库了</p><h3 id="布隆过滤" tabindex="-1"><a class="header-anchor" href="#布隆过滤" aria-hidden="true">#</a> 布隆过滤</h3><p>布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问<code>redis</code>，哪怕此时<code>redis</code>中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到<code>redis</code>中，</p><p>假设布隆过滤器判断这个数据不存在，则直接返回</p><p>这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器走的是哈希思想，只要哈希思想，就可能存在哈希冲突</p><p><img src="'+h+'" alt="1653326156516"></p><h3 id="小总结" tabindex="-1"><a class="header-anchor" href="#小总结" aria-hidden="true">#</a> 小总结</h3><p>缓存穿透产生的原因是什么？</p><ul><li>用户请求的数据在缓存中和数据库中都不存在，不断发起这样的请求，给数据库带来巨大压力</li></ul><p>缓存穿透的解决方案有哪些？</p><ul><li>缓存null值</li><li>布隆过滤</li></ul><h2 id="缓存雪崩问题及解决思路" tabindex="-1"><a class="header-anchor" href="#缓存雪崩问题及解决思路" aria-hidden="true">#</a> 缓存雪崩问题及解决思路</h2><p><strong>缓存雪崩</strong>：是指在同一时段大量的缓存<code>key</code>同时失效或者<code>Redis</code>服务宕机，导致大量请求到达数据库，带来巨大压力。</p><p>核心思路就是避免大量的<code>key</code>在同一时间到期</p><p>解决方案：</p><ul><li>给不同的<code>Key</code>的<code>TTL</code>添加随机值</li><li>利用<code>Redis</code>集群提高服务的可用性</li><li>给缓存业务添加降级限流策略</li><li>给业务添加多级缓存</li></ul><p><img src="'+u+'" alt="1653327884526"></p><h2 id="缓存击穿问题及解决思路" tabindex="-1"><a class="header-anchor" href="#缓存击穿问题及解决思路" aria-hidden="true">#</a> 缓存击穿问题及解决思路</h2><p><strong>缓存击穿</strong>：缓存击穿问题也叫热点<code>Key</code>问题，就是一个被高并发访问并且缓存重建业务较复杂的<code>key</code>突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p><p>常见的解决方案有两种：</p><ul><li>互斥锁</li><li>逻辑过期</li></ul><p>逻辑分析：假设线程1在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程1走完这个逻辑，其他线程就都能从缓存中加载这些数据了，但是假设在线程1没有走完的时候，后续的线程2，线程3，线程4同时过来访问当前这个方法， 那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大</p><p><img src="'+_+'" alt="1653328022622"></p><h3 id="使用锁来解决" tabindex="-1"><a class="header-anchor" href="#使用锁来解决" aria-hidden="true">#</a> 使用锁来解决</h3><p>因为锁能实现互斥性。假设线程过来，只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大，但这也会影响查询的性能，因为此时会让查询的性能从并行变成了串行</p><p>假设现在线程1过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程1就会一个人去执行逻辑，假设现在线程2过来，线程2在执行过程中，并没有获得到锁，那么线程2就可以进行到休眠，直到线程1把锁释放后，线程2获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。</p><p><img src="'+g+'" alt="1653328288627"></p><h3 id="逻辑过期方案" tabindex="-1"><a class="header-anchor" href="#逻辑过期方案" aria-hidden="true">#</a> 逻辑过期方案</h3><p>方案分析：我们之所以会出现这个缓存击穿问题，主要原因是在于我们对<code>key</code>设置了过期时间，假设我们不设置过期时间，其实就不会有缓存击穿的问题</p><p>但是不设置过期时间，这样数据就一直占用我们内存，我们可以采用逻辑过期方案。</p><p>我们把过期时间设置在 <code>redis</code>的<code>value</code>中，假设线程1去查询缓存，然后从<code>value</code>中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个 线程去进行 以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁， 而线程1直接进行返回，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。</p><p>这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。</p><p><img src="'+f+'" alt="1653328663897"></p><p>进行对比</p><p><strong>互斥锁方案：</strong> 由于保证了互斥性，所以数据一致，且实现简单，因为仅仅只需要加一把锁而已，也没其他的事情需要操心，所以没有额外的内存消耗，缺点在于有锁就有死锁问题的发生，且只能串行执行性能肯定受到影响</p><p><strong>逻辑过期方案：</strong> 线程读取过程中不需要等待，性能好，有一个额外的线程持有锁去进行重构数据，但是在重构数据完成前，其他的线程只能返回之前的数据，且实现起来麻烦</p><p><img src="'+m+'" alt="1653357522914"></p>',62);function S(y,C){const a=o("router-link");return s(),r("div",null,[b,e("nav",k,[e("ul",null,[e("li",null,[i(a,{to:"#缓存"},{default:t(()=>[l("缓存")]),_:1}),e("ul",null,[e("li",null,[i(a,{to:"#缓存模型和思路"},{default:t(()=>[l("缓存模型和思路")]),_:1})]),e("li",null,[i(a,{to:"#缓存更新策略"},{default:t(()=>[l("缓存更新策略")]),_:1})])])]),e("li",null,[i(a,{to:"#数据库缓存不一致解决方案"},{default:t(()=>[l("数据库缓存不一致解决方案")]),_:1}),e("ul",null,[e("li",null,[i(a,{to:"#缓存与数据库双写一致"},{default:t(()=>[l("缓存与数据库双写一致")]),_:1})])])]),e("li",null,[i(a,{to:"#缓存穿透问题的解决思路"},{default:t(()=>[l("缓存穿透问题的解决思路")]),_:1}),e("ul",null,[e("li",null,[i(a,{to:"#缓存空对象"},{default:t(()=>[l("缓存空对象")]),_:1})]),e("li",null,[i(a,{to:"#布隆过滤"},{default:t(()=>[l("布隆过滤")]),_:1})]),e("li",null,[i(a,{to:"#小总结"},{default:t(()=>[l("小总结")]),_:1})])])]),e("li",null,[i(a,{to:"#缓存雪崩问题及解决思路"},{default:t(()=>[l("缓存雪崩问题及解决思路")]),_:1})]),e("li",null,[i(a,{to:"#缓存击穿问题及解决思路"},{default:t(()=>[l("缓存击穿问题及解决思路")]),_:1}),e("ul",null,[e("li",null,[i(a,{to:"#使用锁来解决"},{default:t(()=>[l("使用锁来解决")]),_:1})]),e("li",null,[i(a,{to:"#逻辑过期方案"},{default:t(()=>[l("逻辑过期方案")]),_:1})])])])])]),N])}const v=d(x,[["render",S],["__file","Cache.html.vue"]]);export{v as default};
