import{_ as n,M as c,p as l,q as i,R as e,N as d,V as o,t as a,a1 as t}from"./framework-5866ffd3.js";const r="/FullStackNotes/assets/image-20210725144536958-981d82c0.png",p="/FullStackNotes/assets/image-20210725144725943-25f555fc.png",u="/FullStackNotes/assets/image-20210725151319695-ac3eab79.png",v={},m=e("h1",{id:"目录",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#目录","aria-hidden":"true"},"#"),a(" 目录")],-1),R={class:"table-of-contents"},b=t('<h2 id="rdb持久化" tabindex="-1"><a class="header-anchor" href="#rdb持久化" aria-hidden="true">#</a> RDB持久化</h2><p>RDB全称Redis Database Backup file（Redis数据备份文件），也被叫做<code>Redis</code>数据快照。</p><p>简单来说就是把内存中的所有数据都记录到磁盘中。</p><p>当<code>Redis</code>实例故障重启后，从磁盘读取快照文件，恢复数据。</p><p>快照文件称为<code>RDB</code>文件，默认是保存在当前运行目录。</p><h3 id="执行时机" tabindex="-1"><a class="header-anchor" href="#执行时机" aria-hidden="true">#</a> 执行时机</h3><p>RDB持久化在四种情况下会执行：</p><ul><li>执行<code>save</code>命令</li><li>执行<code>bgsave</code>命令</li><li><code>Redis</code>停机时</li><li>触发<code>RDB</code>条件时</li></ul><p><strong>1）save命令</strong></p><p>执行下面的命令，可以立即执行一次RDB：</p><p><img src="'+r+'" alt="image-20210725144536958"></p><p><code>save</code>命令会导致主进程执行<code>RDB</code>，这个过程中其它所有命令都会被阻塞。只有在数据迁移时可能用到。</p><p><strong>2）bgsave命令</strong></p><p>下面的命令可以异步执行RDB：</p><p><img src="'+p+`" alt="image-20210725144725943"></p><p>这个命令执行后会开启独立进程完成<code>RDB</code>，主进程可以持续处理用户请求，不受影响。</p><p><strong>3）停机时</strong></p><p><code>Redis</code>停机时会执行一次<code>save</code>命令，实现<code>RDB</code>持久化。</p><p><strong>4）触发RDB条件</strong></p><p><code>Redis</code>内部有触发<code>RDB</code>的机制，可以在<code>redis.conf</code>文件中找到，格式如下：</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token comment"># 900秒内，如果至少有1个key被修改，则执行bgsave ， 如果是save &quot;&quot; 则表示禁用RDB</span>
<span class="token key attr-name">save</span> <span class="token value attr-value">900 1  </span>
<span class="token key attr-name">save</span> <span class="token value attr-value">300 10  </span>
<span class="token key attr-name">save</span> <span class="token value attr-value">60 10000 </span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>RDB</code>的其它配置也可以在<code>redis.conf</code>文件中设置：</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token comment"># 是否压缩 ,建议不开启，压缩也会消耗cpu，磁盘的话不值钱</span>
<span class="token key attr-name">rdbcompression</span> <span class="token value attr-value">yes</span>

<span class="token comment"># RDB文件名称</span>
<span class="token key attr-name">dbfilename</span> <span class="token value attr-value">dump.rdb  </span>

<span class="token comment"># 文件保存的路径目录</span>
<span class="token key attr-name">dir</span> <span class="token value attr-value">./ </span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="rdb原理" tabindex="-1"><a class="header-anchor" href="#rdb原理" aria-hidden="true">#</a> RDB原理</h3><p><code>bgsave</code>开始时会<code>fork</code>主进程得到子进程，子进程共享主进程的内存数据。完成<code>fork</code>后读取内存数据并写入 <code>RDB</code> 文件。</p><p><code>fork</code>采用的是<code>copy-on-write</code>技术：</p><ul><li>当主进程执行读操作时，访问共享内存；</li><li>当主进程执行写操作时，则会拷贝一份数据，执行写操作。</li></ul><p><img src="`+u+'" alt="image-20210725151319695"></p><h3 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h3><p><code>RDB</code>方式<code>bgsave</code>的基本流程？</p><ul><li><code>fork</code>主进程得到一个子进程，共享内存空间</li><li>子进程读取内存数据并写入新的<code>RDB</code>文件</li><li>用新<code>RDB</code>文件替换旧的<code>RDB</code>文件</li></ul><p><code>RDB</code>会在什么时候执行？<code>save 60 1000</code>代表什么含义？</p><ul><li>默认是服务停止时</li><li>代表60秒内至少执行1000次修改则触发<code>RDB</code></li></ul><p><code>RDB</code>的缺点？</p><ul><li><code>RDB</code>执行间隔时间长，两次<code>RDB</code>之间写入数据有丢失的风险</li><li><code>fork</code>子进程、压缩、写出<code>RDB</code>文件都比较耗时</li></ul>',35);function h(k,B){const s=c("router-link");return l(),i("div",null,[m,e("nav",R,[e("ul",null,[e("li",null,[d(s,{to:"#rdb持久化"},{default:o(()=>[a("RDB持久化")]),_:1}),e("ul",null,[e("li",null,[d(s,{to:"#执行时机"},{default:o(()=>[a("执行时机")]),_:1})]),e("li",null,[d(s,{to:"#rdb原理"},{default:o(()=>[a("RDB原理")]),_:1})]),e("li",null,[d(s,{to:"#小结"},{default:o(()=>[a("小结")]),_:1})])])])])]),b])}const D=n(v,[["render",h],["__file","RDB.html.vue"]]);export{D as default};
