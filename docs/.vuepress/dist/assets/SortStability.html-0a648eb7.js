import{_ as d,M as i,p as l,q as h,R as a,N as r,V as n,t as e,a1 as s}from"./framework-5866ffd3.js";const o="/FullStackNotes/assets/image-20230407133044780-d81da8d5.png",c={},u=a("h1",{id:"目录",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#目录","aria-hidden":"true"},"#"),e(" 目录")],-1),_={class:"table-of-contents"},f=s('<h1 id="排序的稳定性" tabindex="-1"><a class="header-anchor" href="#排序的稳定性" aria-hidden="true">#</a> 排序的稳定性</h1><h2 id="稳定性的定义" tabindex="-1"><a class="header-anchor" href="#稳定性的定义" aria-hidden="true">#</a> <strong>稳定性的定义：</strong></h2><p>数组arr中有若干元素，其中A元素和B元素相等，并且A元素在B元素前面，如果使用某种排序算法排序后，能够保 证A元素依然在B元素的前面，可以说这个该算法是稳定的。</p><p><img src="'+o+'" alt="image-20230407133044780"></p><h2 id="稳定性的意义" tabindex="-1"><a class="header-anchor" href="#稳定性的意义" aria-hidden="true">#</a> <strong>稳定性的意义：</strong></h2><p>如果一组数据只需要一次排序，则稳定性一般是没有意义的，如果一组数据需要多次排序，稳定性是有意义的。例 如要排序的内容是一组商品对象，第一次排序按照价格由低到高排序，第二次排序按照销量由高到低排序，如果第 二次排序使用稳定性算法，就可以使得相同销量的对象依旧保持着价格高低的顺序展现，只有销量不同的对象才需 要重新排序。这样既可以保持第一次排序的原有意义，而且可以减少系统开销。</p><h2 id="常见排序算法的稳定性" tabindex="-1"><a class="header-anchor" href="#常见排序算法的稳定性" aria-hidden="true">#</a> 常见排序算法的稳定性</h2><h3 id="冒泡排序" tabindex="-1"><a class="header-anchor" href="#冒泡排序" aria-hidden="true">#</a> 冒泡排序</h3><p>只有当arr[i]&gt;arr[i+1]的时候，才会交换元素的位置，而相等的时候并不交换位置，所以冒泡排序是一种<strong>稳定排序算法</strong>。</p><h3 id="选择排序" tabindex="-1"><a class="header-anchor" href="#选择排序" aria-hidden="true">#</a> 选择排序</h3><p>选择排序是给每个位置选择当前元素最小的,例如有数据{5(1)，8 ，5(2)， 2， 9 },第一遍选择到的最小元素为2， 所以5(1)会和2进行交换位置，此时5(1)到了5(2)后面，破坏了稳定性，所以选择排序是一种<strong>不稳定的排序算法</strong>。</p><h3 id="插入排序" tabindex="-1"><a class="header-anchor" href="#插入排序" aria-hidden="true">#</a> 插入排序</h3><p>比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其 后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么把要插入的元素放在相等 元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是<strong>稳定的</strong>。</p><h3 id="希尔排序" tabindex="-1"><a class="header-anchor" href="#希尔排序" aria-hidden="true">#</a> 希尔排序</h3><p>希尔排序是按照不同步长对元素进行插入排序 ,虽然一次插入排序是稳定的，不会改变相同元素的相对顺序，但在 不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以希尔排序是<strong>不稳定的</strong>。</p><h3 id="归并排序" tabindex="-1"><a class="header-anchor" href="#归并排序" aria-hidden="true">#</a> 归并排序</h3><p>归并排序在归并的过程中，只有arr[i]&lt;arr[i+1]的时候才会交换位置，如果两个元素相等则不会交换位置，所以它并不会破坏稳定性，归并排序是<strong>稳定的</strong>。</p><h3 id="快速排序" tabindex="-1"><a class="header-anchor" href="#快速排序" aria-hidden="true">#</a> 快速排序</h3><p>快速排序需要一个基准值，在基准值的右侧找一个比基准值小的元素，在基准值的左侧找一个比基准值大的元素， 然后交换这两个元素，此时会破坏稳定性，所以快速排序是一种<strong>不稳定的算法</strong>。</p>',19);function p(g,x){const t=i("router-link");return l(),h("div",null,[u,a("nav",_,[a("ul",null,[a("li",null,[r(t,{to:"#稳定性的定义"},{default:n(()=>[e("稳定性的定义：")]),_:1})]),a("li",null,[r(t,{to:"#稳定性的意义"},{default:n(()=>[e("稳定性的意义：")]),_:1})]),a("li",null,[r(t,{to:"#常见排序算法的稳定性"},{default:n(()=>[e("常见排序算法的稳定性")]),_:1}),a("ul",null,[a("li",null,[r(t,{to:"#冒泡排序"},{default:n(()=>[e("冒泡排序")]),_:1})]),a("li",null,[r(t,{to:"#选择排序"},{default:n(()=>[e("选择排序")]),_:1})]),a("li",null,[r(t,{to:"#插入排序"},{default:n(()=>[e("插入排序")]),_:1})]),a("li",null,[r(t,{to:"#希尔排序"},{default:n(()=>[e("希尔排序")]),_:1})]),a("li",null,[r(t,{to:"#归并排序"},{default:n(()=>[e("归并排序")]),_:1})]),a("li",null,[r(t,{to:"#快速排序"},{default:n(()=>[e("快速排序")]),_:1})])])])])]),f])}const m=d(c,[["render",p],["__file","SortStability.html.vue"]]);export{m as default};
