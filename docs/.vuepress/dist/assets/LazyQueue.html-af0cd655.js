import{_ as u,M as o,p as d,q as s,R as e,N as i,V as t,t as a,a1 as c}from"./framework-5866ffd3.js";const n="/FullStackNotes/assets/image-20210718194040498-0b14cf5d.png",r="/FullStackNotes/assets/image-20210718194522223-8673ddc8.png",h="/FullStackNotes/assets/image-20210718194539054-b8352f3b.png",p={},b=e("h1",{id:"目录",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#目录","aria-hidden":"true"},"#"),a(" 目录")],-1),q={class:"table-of-contents"},_=c('<h2 id="消息堆积问题" tabindex="-1"><a class="header-anchor" href="#消息堆积问题" aria-hidden="true">#</a> 消息堆积问题</h2><p>当生产者发送消息的速度超过了消费者处理消息的速度，就会导致队列中的消息堆积，直到队列存储消息达到上限。之后发送的消息就会成为死信，可能会被丢弃，这就是消息堆积问题。</p><p><img src="'+n+`" alt="image-20210718194040498"></p><p>解决消息堆积有两种思路：</p><ul><li>增加更多消费者，提高消费速度。也就是我们之前说的<code>work queue</code>模式</li><li>扩大队列容积，提高堆积上限</li></ul><p>要提升队列容积，把消息保存在内存中显然是不行的。</p><h2 id="惰性队列" tabindex="-1"><a class="header-anchor" href="#惰性队列" aria-hidden="true">#</a> 惰性队列</h2><p>从<code>RabbitMQ</code>的<code>3.6.0</code>版本开始，就增加了<code>Lazy Queues</code>的概念，也就是惰性队列。惰性队列的特征如下：</p><ul><li>接收到消息后直接存入磁盘而非内存</li><li>消费者要消费消息时才会从磁盘中读取并加载到内存</li><li>支持数百万条的消息存储</li></ul><h3 id="基于命令行设置lazy-queue" tabindex="-1"><a class="header-anchor" href="#基于命令行设置lazy-queue" aria-hidden="true">#</a> 基于命令行设置lazy-queue</h3><p>而要设置一个队列为惰性队列，只需要在声明队列时，指定<code>x-queue-mode</code>属性为<code>lazy</code>即可。可以通过命令行将一个运行中的队列修改为惰性队列：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>rabbitmqctl set_policy Lazy <span class="token string">&quot;^lazy-queue$&quot;</span> <span class="token string">&#39;{&quot;queue-mode&quot;:&quot;lazy&quot;}&#39;</span> --apply-to queues  
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>命令解读：</p><ul><li><code>rabbitmqctl</code> ：<code>RabbitMQ</code>的命令行工具</li><li><code>set_policy</code> ：添加一个策略</li><li><code>Lazy</code> ：策略名称，可以自定义</li><li><code>&quot;^lazy-queue$&quot;</code> ：用正则表达式匹配队列的名字</li><li><code>&#39;{&quot;queue-mode&quot;:&quot;lazy&quot;}&#39;</code> ：设置队列模式为lazy模式</li><li><code>--apply-to queues </code>：策略的作用对象，是所有的队列</li></ul><h3 id="基于-bean声明lazy-queue" tabindex="-1"><a class="header-anchor" href="#基于-bean声明lazy-queue" aria-hidden="true">#</a> 基于@Bean声明lazy-queue</h3><p><img src="`+r+'" alt="image-20210718194522223"></p><h3 id="基于-rabbitlistener声明lazyqueue" tabindex="-1"><a class="header-anchor" href="#基于-rabbitlistener声明lazyqueue" aria-hidden="true">#</a> 基于@RabbitListener声明LazyQueue</h3><p><img src="'+h+'" alt="image-20210718194539054"></p><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h3><p>消息堆积问题的解决方案？</p><ul><li>队列上绑定多个消费者，提高消费速度</li><li>使用惰性队列，可以再<code>mq</code>中保存更多消息</li></ul><p>惰性队列的优点有哪些？</p><ul><li>基于磁盘存储，消息上限高</li><li>没有间歇性的<code>page-out</code>，性能比较稳定</li></ul><p>惰性队列的缺点有哪些？</p><ul><li>基于磁盘存储，消息时效性会降低</li><li>性能受限于磁盘的IO</li></ul>',25);function m(y,z){const l=o("router-link");return d(),s("div",null,[b,e("nav",q,[e("ul",null,[e("li",null,[i(l,{to:"#消息堆积问题"},{default:t(()=>[a("消息堆积问题")]),_:1})]),e("li",null,[i(l,{to:"#惰性队列"},{default:t(()=>[a("惰性队列")]),_:1}),e("ul",null,[e("li",null,[i(l,{to:"#基于命令行设置lazy-queue"},{default:t(()=>[a("基于命令行设置lazy-queue")]),_:1})]),e("li",null,[i(l,{to:"#基于-bean声明lazy-queue"},{default:t(()=>[a("基于@Bean声明lazy-queue")]),_:1})]),e("li",null,[i(l,{to:"#基于-rabbitlistener声明lazyqueue"},{default:t(()=>[a("基于@RabbitListener声明LazyQueue")]),_:1})]),e("li",null,[i(l,{to:"#总结"},{default:t(()=>[a("总结")]),_:1})])])])])]),_])}const g=u(p,[["render",m],["__file","LazyQueue.html.vue"]]);export{g as default};
