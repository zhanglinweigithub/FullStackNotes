---
title: 缓存
---
# 目录
[[toc]]
## 缓存

### 缓存模型和思路

标准的操作方式就是查询数据库之前先查询缓存，如果缓存数据存在，则直接从缓存中返回，如果缓存数据不存在，再查询数据库，然后将数据存入`redis`。

![1653322097736](./img/1653322097736.png)



### 缓存更新策略

**内存淘汰：**`redis`自动进行，当`redis`内存达到咱们设定的`max-memery`的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)

**超时剔除：** 当我们给`redis`设置了过期时间`ttl`之后，`redis`会将超时的数据进行删除，方便咱们继续使用缓存

**主动更新：** 我们可以手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题

![1653322506393](./img/1653322506393.png)

## 数据库缓存不一致解决方案

- **Cache Aside Pattern** ：人工编码方式，缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案
- **Read/Write Through Pattern** : 由系统本身完成，数据库与缓存的问题交由系统本身去处理
- **Write Behind Caching Pattern** ：调用者只操作缓存，其他线程去异步处理数据库，实现最终一致



**综合考虑使用方案一**

* 删除缓存还是更新缓存？
  * 更新缓存：每次更新数据库都更新缓存，无效写操作较多
  * 删除缓存：更新数据库时让缓存失效，查询时再更新缓存

* 如何保证缓存与数据库的操作的同时成功或失败？
  * 单体系统，将缓存与数据库操作放在一个事务
  * 分布式系统，利用TCC等分布式事务方案

* 先操作缓存还是先操作数据库？
  * 先删除缓存，再操作数据库
  * 先操作数据库，再删除缓存

应当是先操作数据库，再删除缓存

原因在于，如果你选择第一种方案，在两个线程并发来访问时，假设线程1先来，他先把缓存删了，此时线程2过来，他查询缓存数据并不存在，此时他写入缓存，当他写入缓存后，线程1再执行更新动作时，实际上写入的就是旧的数据，新的数据被旧数据覆盖了。

### 缓存与数据库双写一致

核心思路如下：

根据id查询店铺时，如果缓存未命中，则查询数据库，将数据库结果写入缓存，并设置超时时间

根据id修改店铺时，先修改数据库，再删除缓存

## 缓存穿透问题的解决思路

**缓存穿透** ：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。

常见的解决方案有两种：

* 缓存空对象
  * 优点：实现简单，维护方便
  * 缺点：
    * 额外的内存消耗
    * 可能造成短期的不一致
* 布隆过滤
  * 优点：内存占用较少，没有多余key
  * 缺点：
    * 实现复杂
    * 存在误判可能



### 缓存空对象

当我们客户端访问不存在的数据时，先请求`redis`，但是此时`redis`中没有数据，此时会访问到数据库，但是数据库中也没有数据

此时我们在`redis`中存入一个空对象，这样，下次用户过来访问这个不存在的数据，那么在`redis`中也能找到这个数据就不会进入到数据库了



### 布隆过滤

布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问`redis`，哪怕此时`redis`中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到`redis`中，

假设布隆过滤器判断这个数据不存在，则直接返回

这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器走的是哈希思想，只要哈希思想，就可能存在哈希冲突

![1653326156516](./img/1653326156516.png)

### 小总结

缓存穿透产生的原因是什么？

* 用户请求的数据在缓存中和数据库中都不存在，不断发起这样的请求，给数据库带来巨大压力

缓存穿透的解决方案有哪些？

* 缓存null值
* 布隆过滤



## 缓存雪崩问题及解决思路

**缓存雪崩**：是指在同一时段大量的缓存`key`同时失效或者`Redis`服务宕机，导致大量请求到达数据库，带来巨大压力。

核心思路就是避免大量的`key`在同一时间到期

解决方案：

* 给不同的`Key`的`TTL`添加随机值
* 利用`Redis`集群提高服务的可用性
* 给缓存业务添加降级限流策略
* 给业务添加多级缓存

![1653327884526](./img/1653327884526.png)

## 缓存击穿问题及解决思路

**缓存击穿**：缓存击穿问题也叫热点`Key`问题，就是一个被高并发访问并且缓存重建业务较复杂的`key`突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。

常见的解决方案有两种：

* 互斥锁
* 逻辑过期

逻辑分析：假设线程1在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程1走完这个逻辑，其他线程就都能从缓存中加载这些数据了，但是假设在线程1没有走完的时候，后续的线程2，线程3，线程4同时过来访问当前这个方法， 那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大



![1653328022622](./img/1653328022622.png)



### 使用锁来解决

因为锁能实现互斥性。假设线程过来，只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大，但这也会影响查询的性能，因为此时会让查询的性能从并行变成了串行

假设现在线程1过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程1就会一个人去执行逻辑，假设现在线程2过来，线程2在执行过程中，并没有获得到锁，那么线程2就可以进行到休眠，直到线程1把锁释放后，线程2获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。

![1653328288627](./img/1653328288627.png)

### 逻辑过期方案

方案分析：我们之所以会出现这个缓存击穿问题，主要原因是在于我们对`key`设置了过期时间，假设我们不设置过期时间，其实就不会有缓存击穿的问题

但是不设置过期时间，这样数据就一直占用我们内存，我们可以采用逻辑过期方案。

我们把过期时间设置在 `redis`的`value`中，假设线程1去查询缓存，然后从`value`中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个 线程去进行 以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁， 而线程1直接进行返回，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。

这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。

![1653328663897](./img/1653328663897.png)

进行对比

**互斥锁方案：** 由于保证了互斥性，所以数据一致，且实现简单，因为仅仅只需要加一把锁而已，也没其他的事情需要操心，所以没有额外的内存消耗，缺点在于有锁就有死锁问题的发生，且只能串行执行性能肯定受到影响

**逻辑过期方案：** 线程读取过程中不需要等待，性能好，有一个额外的线程持有锁去进行重构数据，但是在重构数据完成前，其他的线程只能返回之前的数据，且实现起来麻烦

![1653357522914](./img/1653357522914.png)
